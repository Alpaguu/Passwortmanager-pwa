<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sicherer Passwort-Manager</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <link rel="manifest" href="manifest.webmanifest">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'SF Pro Display', 'Inter', sans-serif;
            background: #ffffff;
            min-height: 100vh;
            color: #1a1a1a;
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #ffffff;
            min-height: 100vh;
            padding-left: 12px;
            padding-right: 12px;
        }

        .header {
            background: #ffffff;
            color: #1a1a1a;
            padding: 60px 24px 40px;
            text-align: center;
            position: relative;
            -webkit-app-region: drag; /* üñ±Ô∏è Macht Header bewegbar */
        }

        .app-version {
            position: fixed;
            top: 52px;
            right: 12px;
            background: #f3f4f6;
            color: #6b7280;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            z-index: 1000;
            font-variant-numeric: tabular-nums;
            -webkit-app-region: no-drag; /* üö´ Version-Badge nicht drag-bar */
        }

        .top-actions {
            position: fixed;
            top: 12px;
            right: 12px;
            left: auto;
            display: flex;
            gap: 2px;
            z-index: 1000;
            -webkit-app-region: no-drag;
            align-items: center;
        }

        .btn-fresh {
            background: #1a1a1a !important;
            color: white !important;
            border: none !important;
            padding: 8px 16px !important;
            border-radius: 6px !important;
            font-size: 13px !important;
            font-weight: 500 !important;
            cursor: pointer;
            transition: all 0.15s ease;
            width: auto !important;
            height: 36px;
            display: flex;
            align-items: center;
        }

        .btn-fresh:hover {
            background: #000000 !important;
            transform: translateY(-1px);
        }

        .btn-fresh.btn-secondary {
            background: #6b7280 !important;
        }

        .btn-fresh.btn-secondary:hover {
            background: #4b5563 !important;
        }

        .btn-fresh.btn-logout {
            background: #dc2626 !important;
        }

        .btn-fresh.btn-logout:hover {
            background: #b91c1c !important;
        }

        /* Session Timer Styles - Elegant & Minimal */
        .session-timer {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 8px 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
            min-width: 140px;
            font-size: 13px;
            color: #64748b;
            font-weight: 500;
            height: 36px;
            display: flex;
            align-items: center;
        }

        .session-timer:hover {
            background: #f1f5f9;
            border-color: #cbd5e1;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }

        .session-timer-content {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .session-timer-icon {
            font-size: 14px;
            opacity: 0.8;
        }

        .session-timer-text {
            color: inherit;
            font-size: inherit;
            font-weight: inherit;
        }

        /* Warning state when time is running low */
        .session-timer.warning {
            background: #fef3c7;
            border-color: #f59e0b;
            color: #92400e;
        }

        .session-timer.warning:hover {
            background: #fde68a;
            border-color: #d97706;
        }

        /* Critical state for last few seconds */
        .session-timer.critical {
            background: #fee2e2;
            border-color: #ef4444;
            color: #991b1b;
            animation: gentle-pulse 1.5s ease-in-out infinite alternate;
        }

        .session-timer.critical:hover {
            background: #fecaca;
            border-color: #dc2626;
        }

        @keyframes gentle-pulse {
            from {
                opacity: 1;
            }
            to {
                opacity: 0.8;
            }
        }

        .header h1 {
            font-size: 2.2rem;
            font-weight: 600;
            margin-bottom: 8px;
            letter-spacing: -0.025em;
        }

        .header p {
            color: #6b7280;
            font-size: 1rem;
            font-weight: 400;
        }

        .login-screen {
            padding: 0 24px 60px;
            text-align: center;
            background: #ffffff;
        }

        .login-form {
            max-width: 400px;
            margin: 0 auto;
        }

        .form-group {
            margin-bottom: 20px;
            text-align: left;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #374151;
            font-size: 0.875rem;
        }

        .form-group input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.15s ease;
            background: #ffffff;
        }

        .form-group input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        /* üñ±Ô∏è Alle interaktiven Elemente nicht drag-bar machen */
        button, input, select, textarea, .btn, [role="button"], .close, 
        .modal-content, .notification {
            -webkit-app-region: no-drag;
        }

        /* Modal select styling (folder dropdown) same as entry select */
        .form-group select {
            width: 100%;
            padding: 12px 40px 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 16px;
            background: #ffffff;
            transition: all 0.15s ease;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 20 20' fill='none'%3E%3Cpath d='M6 8l4 4 4-4' stroke='%236b7280' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px;
        }

        .form-group select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .btn {
            background: #1a1a1a;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            width: 100%;
        }

        .btn:hover {
            background: #000000;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: #f9fafb;
            color: #374151;
            border: 1px solid #d1d5db;
        }

        .btn-secondary:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
        }

        .btn-danger {
            background: #ef4444;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .btn-success {
            background: #10b981;
        }

        .btn-success:hover {
            background: #059669;
        }

        .main-content {
            display: none;
            padding: 0 24px 60px;
            background: #ffffff;
        }

        .toolbar {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-bottom: 32px;
            padding: 24px 0;
            border-bottom: 1px solid #f3f4f6;
        }

        .toolbar-row {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-items: flex-start;
        }

        .toolbar-row-1 {
            align-items: center;
        }

        .toolbar-row-2 {
            align-items: flex-start;
        }

        .search-box {
            flex: 1;
            min-width: 300px;
            position: relative;
        }

        .search-box input {
            width: 100%;
            padding: 12px 40px 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 15px;
            background: #ffffff;
        }

        .search-box input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .search-icon {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #9ca3af;
            font-size: 16px;
        }

        .sort-box {
            min-width: 180px;
        }

        .sort-box select {
            width: 100%;
            padding: 12px 40px 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 15px;
            background: #ffffff;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 20 20' fill='none'%3E%3Cpath d='M6 8l4 4 4-4' stroke='%236b7280' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px;
            cursor: pointer;
        }

        .sort-box select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        /* Custom dropdown styling for better design integration */
        .sort-box select option,
        .folder-box select option,
        .type-filter-box select option {
            background: #ffffff;
            color: #111827;
            padding: 12px 16px;
            border: none;
            font-size: 15px;
        }

        .sort-box select option:hover,
        .folder-box select option:hover,
        .type-filter-box select option:hover {
            background: #f3f4f6;
        }

        .sort-box select option:checked,
        .type-filter-box select option:checked {
            background: #1a1a1a;
            color: #ffffff;
        }

        .btn-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        /* Toolbar buttons side-by-side */
        .toolbar .btn-group .btn {
            width: auto;
            padding: 12px 20px;
        }

        /* Drag & Drop folder bar */
        .folder-dnd-bar {
            display: flex;
            gap: 10px;
            flex-wrap: wrap; /* wrap to next line when no horizontal space */
            overflow: visible;
            padding: 8px 2px 8px 2px;
            margin-top: -8px;
            margin-bottom: 16px;
        }

        .folder-drop {
            flex: 0 0 auto;
            min-width: 140px;
            padding: 10px 12px;
            border: 1px dashed #d1d5db;
            border-radius: 10px;
            color: #1f2937;
            background: #fafafa;
            text-align: center;
            user-select: none;
            transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
        }

        .folder-drop.active {
            border-color: #3b82f6;
            background: #eff6ff;
            color: #1f2937;
        }

        .folder-drop.drag-over {
            border-color: #111827;
            background: #f3f4f6;
        }

        .folder-drop .name {
            font-weight: 600;
            font-size: 0.95rem;
        }

        .password-item[draggable="true"] {
            cursor: grab;
        }

        .password-item.dragging {
            opacity: 0.6;
        }

        /* Entry type styling */
        .password-item.entry-website {
            border-left: 4px solid #007bff;
        }
        
        .password-item.entry-link {
            border-left: 4px solid #17a2b8;
        }
        
        .password-item.entry-note {
            border-left: 4px solid #28a745;
        }
        
        .password-item.entry-password {
            border-left: 4px solid #dc3545;
        }

        /* Type filter container styling - Desktop */
        .type-filter-container {
            display: flex;
            flex-direction: column;
        }
        
        .type-filter-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .type-filter-btn {
            padding: 8px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            background: #ffffff;
            color: #6b7280;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            min-height: 40px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .type-filter-btn:hover {
            background: #f9fafb;
            border-color: #d1d5db;
            color: #374151;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .type-filter-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: #ffffff;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
        }
        
        .type-filter-btn.active:hover {
            background: #2563eb;
            border-color: #2563eb;
            transform: translateY(-1px);
        }

        /* Type filter box styling - Mobile fallback */
        .type-filter-box {
            min-width: 180px;
        }
        
        .type-filter-box select {
            width: 100%;
            padding: 12px 40px 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 15px;
            background: #ffffff;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 20 20' fill='none'%3E%3Cpath d='M6 8l4 4 4-4' stroke='%236b7280' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 20px 20px;
            cursor: pointer;
        }

        .type-filter-box select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        /* Responsive visibility controls */
        .desktop-only {
            display: block;
        }
        
        .mobile-only {
            display: none;
        }

        .folder-box {
            min-width: 220px;
        }

        .folder-box select {
            width: 100%;
            padding: 12px 40px 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 15px;
            background: #ffffff;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 20 20' fill='none'%3E%3Cpath d='M6 8l4 4 4-4' stroke='%236b7280' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px;
            cursor: pointer;
        }

        .folder-box select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }



        .passwords-list {
            margin-bottom: 40px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }

        /* Desktop: show items in multiple columns for better use of wide screens */
        @media (min-width: 900px) {
            .passwords-list {
                grid-template-columns: repeat(2, minmax(360px, 1fr));
            }
            .password-item {
                height: auto;
            }
            .row-main {
                flex: 1 1 300px;
            }
        }
        @media (min-width: 1200px) {
            .passwords-list {
                grid-template-columns: repeat(3, minmax(360px, 1fr));
            }
        }
        @media (min-width: 1600px) {
            .passwords-list {
                grid-template-columns: repeat(4, minmax(320px, 1fr));
            }
        }

        .password-item {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 0;
            transition: all 0.15s ease;
            overflow: hidden;
        }

        .password-item:hover {
            border-color: #d1d5db;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        .password-header {
            padding: 14px 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #ffffff;
            transition: background-color 0.15s ease;
        }

        .password-header:hover {
            background: #f9fafb;
        }

        .password-header h3 {
            color: #111827;
            font-size: 1rem;
            font-weight: 600;
            margin: 0;
            flex: 1;
        }

        .password-header .expand-icon {
            color: #6b7280;
            font-size: 18px;
            transition: transform 0.2s ease;
        }

        .password-item.expanded .expand-icon {
            transform: rotate(180deg);
        }

        /* Chevron arrow (nicer fold icon) */
        .chevron {
            width: 10px;
            height: 10px;
            border-right: 2px solid #6b7280;
            border-bottom: 2px solid #6b7280;
            transform: rotate(45deg);
            transition: transform 0.2s ease, border-color 0.2s ease;
            display: inline-block;
            margin-left: 8px;
        }
        .password-item.expanded .chevron { transform: rotate(-135deg); border-color: #374151; }

        /* Compact row (no expand) */
        .password-row {
            padding: 12px 14px;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap; /* allow actions to wrap instead of shrinking title to zero */
        }
        .row-main {
            flex: 1 1 240px; /* keep some space for title; can grow and shrink, base ~240px */
            min-width: 0;     /* enable ellipsis */
        }
        .row-title {
            color: #111827;
            font-size: 0.98rem;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .row-sub {
            color: #6b7280;
            font-size: 0.8rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .row-meta { /* inline compact details: password, url, note */
            margin-top: 6px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        .chip {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            color: #374151;
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            max-width: 100%;
        }
        .chip input {
            background: transparent;
            border: none;
            font: inherit;
            width: 120px;
            outline: none;
        }
        .chip-note {
            white-space: normal;
            overflow: visible;
            text-overflow: initial;
            max-width: none;
            word-break: break-word;
            flex: 1 1 100%; /* take full row for readability */
        }
        .chip a { color: inherit; text-decoration: none; }
        .quick-actions {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            flex: 0 1 520px; /* allow wrapping when not enough width in the card */
            flex-wrap: wrap;
            justify-content: flex-start; /* align actions to the left */
            row-gap: 6px;
        }
        .icon-btn {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            color: #374151;
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
        }
        .icon-btn:hover { background: #f3f4f6; }
        .icon-btn.compact {
            padding: 4px 6px;
            font-size: 12px;
        }

        /* Colored action pills for better visual scanning */
        .pill-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            border: 1px solid transparent;
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            line-height: 1;
            background: #f3f4f6;
            color: #374151;
        }
        .pill-btn.edit {
            background: #dbeafe; /* blue-100 */
            color: #1e40af;      /* blue-800 */
            border-color: #bfdbfe; /* blue-200 */
        }
        .pill-btn.edit:hover { background: #bfdbfe; }
        .pill-btn.danger {
            background: #fee2e2; /* red-100 */
            color: #991b1b;      /* red-800 */
            border-color: #fecaca; /* red-200 */
        }
        .pill-btn.danger:hover { background: #fecaca; }
        /* tweak compact select inside quick actions */
        .quick-actions select.icon-btn {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            padding-right: 24px;
            max-width: 160px;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        /* Footer row to hold edit/delete at bottom */
        .row-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding: 8px 14px 14px 14px;
        }
        .row-footer .pill-btn { padding: 10px 14px; font-size: 13px; }

        /* Folder chips selector inside card */
        .folder-chips {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            background: #f3f4f6;
            padding: 10px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
        }
        .folder-chip {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            padding: 6px 10px;
            border-radius: 999px;
            font-size: 12px;
            cursor: pointer;
        }
        .folder-chip:hover { background: #f9fafb; }
        .folder-chip.selected {
            background: #111827;
            color: #ffffff;
            border-color: #111827;
        }

        .password-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            background: #f9fafb;
            border-top: 1px solid #e5e7eb;
        }

        .password-item.expanded .password-content {
            max-height: 1000px;
        }

        .password-details {
            padding: 18px 20px;
        }

        /* Stacked fields on all sizes (Ordner ‚Üí Benutzername ‚Üí Passwort ‚Üí URL ‚Üí Notizen) */
        @media (min-width: 900px) {
            .password-details { display: block; }
        }

        .password-field {
            margin-bottom: 12px;
        }

        .password-field label {
            display: block;
            font-weight: 500;
            color: #6b7280;
            margin-bottom: 6px;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .password-field .value {
            background: #f9fafb;
            padding: 10px 14px;
            border-radius: 6px;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border: 1px solid #e5e7eb;
        }

        /* New layout for URL fields with actions */
        .password-field .value-with-actions {
            background: #f9fafb;
            border-radius: 6px;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            border: 1px solid #e5e7eb;
            overflow: hidden;
        }

        .password-field .value-content {
            padding: 10px 14px;
            background: #f9fafb;
        }

        .password-field .value-content input {
            background: transparent;
            border: none;
            font-family: inherit;
            font-size: 14px;
            width: 100%;
            outline: none;
            color: #111827;
        }

        .password-field .value-actions {
            background: #f1f5f9;
            padding: 8px 14px;
            border-top: 1px solid #e5e7eb;
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .password-field .value-actions .copy-btn {
            background: #fff;
            border: 1px solid #d1d5db;
            color: #374151;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .password-field .value-actions .copy-btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
            transform: translateY(-1px);
        }

        .password-field .value-actions .copy-btn:active {
            transform: translateY(0);
        }

        /* Nicer select styling for folder dropdowns */
        .password-field .value select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-color: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            padding: 10px 36px 10px 12px;
            font-size: 14px;
            color: #111827;
            cursor: pointer;
            width: 220px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 20 20' fill='none'%3E%3Cpath d='M6 8l4 4 4-4' stroke='%236b7280' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 16px;
        }

        .password-field .value select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .password-field .value input {
            background: transparent;
            border: none;
            font-family: inherit;
            font-size: 14px;
            width: 100%;
            outline: none;
            color: #111827;
        }

        /* Special styling for notes field */
        .password-field.full .value {
            align-items: flex-start;
            min-height: 60px;
        }

        .password-field.full .value textarea {
            background: transparent;
            border: none;
            font-family: inherit;
            font-size: 14px;
            width: 100%;
            outline: none;
            color: #111827;
            resize: none;
            min-height: 60px;
            max-height: 200px;
            overflow-y: auto;
            line-height: 1.5;
            padding: 0;
        }

        .copy-btn {
            background: #1a1a1a;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 11px;
            margin-left: 6px;
            font-weight: 500;
            transition: background 0.15s ease;
        }

        .copy-btn:hover {
            background: #000000;
        }

        .card-actions {
            display: flex;
            gap: 8px;
            margin-top: 16px;
        }

        .card-actions .btn {
            flex: 1;
            padding: 6px 10px;
            font-size: 12px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            overflow-y: auto; /* allow scrolling when content is taller than viewport */
        }

        .modal-content {
            background-color: #ffffff;
            margin: 5% auto;
            padding: 32px;
            border-radius: 16px;
            width: 90%;
            max-width: 480px;
            max-height: 90vh; /* constrain height */
            overflow-y: auto; /* scroll inside modal */
            position: relative;
            animation: modalSlideIn 0.2s ease;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-10px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .close {
            position: absolute;
            right: 24px;
            top: 24px;
            font-size: 20px;
            font-weight: 400;
            cursor: pointer;
            color: #9ca3af;
            line-height: 1;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            transition: all 0.15s ease;
            -webkit-app-region: no-drag; /* üñ±Ô∏è X-Button muss klickbar sein! */
        }

        .close:hover {
            color: #374151;
            background: #f3f4f6;
        }

        .modal h2 {
            margin-bottom: 24px;
            color: #111827;
            font-weight: 600;
            font-size: 1.25rem;
        }

        .empty-state {
            text-align: center;
            padding: 80px 20px;
            color: #888;
        }

        .empty-state h3 {
            margin-bottom: 16px;
            color: #2c2c2c;
            font-weight: 400;
        }

        .notification {
            position: fixed;
            top: 24px;
            right: 24px;
            padding: 12px 20px;
            border-radius: 12px;
            color: white;
            font-weight: 500;
            z-index: 1001;
            transform: translateX(120%);
            transition: transform 0.2s ease;
            font-size: 14px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            background: #10b981;
        }

        .notification.error {
            background: #ef4444;
        }

        .strength-meter {
            height: 3px;
            background: #f0f0f0;
            border-radius: 2px;
            margin-top: 6px;
            overflow: hidden;
        }

        .strength-bar {
            height: 100%;
            transition: width 0.2s ease, background-color 0.2s ease;
        }

        .strength-weak { background: #dc3545; }
        .strength-medium { background: #ffc107; }
        .strength-strong { background: #28a745; }

        /* Folder modal styling */
        .folders-modal-content {
            max-width: 560px;
        }

        .folder-input-group {
            display: flex;
            gap: 8px;
            align-items: end;
        }

        .folder-input-group input {
            flex: 1;
        }

        .folder-input-group button {
            width: auto;
            white-space: nowrap;
        }

        /* Folder list items - responsive design */
        .folder-item {
            transition: background-color 0.2s ease;
        }

        .folder-item:hover {
            background-color: #f9fafb;
        }

        /* Desktop: horizontal layout for folder items */
        @media (min-width: 769px) {
            .folder-item {
                display: flex !important;
                align-items: center !important;
                gap: 12px !important;
                padding: 12px 0 !important;
            }

            .folder-item input {
                flex: 1 !important;
                margin-bottom: 0 !important;
            }

            .folder-button-group {
                flex-shrink: 0 !important;
            }

            .folder-button-group button {
                flex: none !important;
                width: auto !important;
                min-width: 100px !important;
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }

            .top-actions {
                position: static !important;
                justify-content: center;
                margin-bottom: 16px;
                margin-top: 16px;
                right: auto !important;
                left: auto !important;
            }

            .app-version {
                position: static !important;
                order: 2;
                margin-top: 8px;
                margin-bottom: 16px;
                align-self: center;
            }





            .toolbar-row {
                flex-direction: column;
                align-items: stretch;
            }

            .toolbar-row-2 .btn-group {
                margin-top: 16px;
                width: 100%;
            }

            /* Mobile: Hide desktop type filter and show tiles */
            .desktop-only {
                display: none !important;
            }
            
            .mobile-only {
                display: block !important;
            }

            /* Mobile Type Filter Tiles */
            .type-filter-tiles {
                display: flex !important;
                gap: 6px;
                margin-bottom: 16px;
                overflow-x: auto;
                padding: 2px;
            }

            .type-tile {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                min-width: 60px;
                padding: 12px 8px;
                border: 1px solid #d1d5db;
                border-radius: 8px;
                background: #ffffff;
                color: #6b7280;
                font-size: 11px;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.2s ease;
                white-space: nowrap;
                flex-shrink: 0;
            }

            .type-tile:hover {
                background: #f9fafb;
                border-color: #9ca3af;
            }

            .type-tile.active {
                background: #111827;
                color: #ffffff;
                border-color: #111827;
            }

            .type-tile span {
                margin-top: 4px;
                font-size: 10px;
                line-height: 1.2;
                text-align: center;
            }

            /* Mobile: Make all dropdowns consistent width */
            .type-filter-box,
            .folder-box,
            .sort-box {
                min-width: unset;
                width: 100%;
                margin-bottom: 12px;
            }

            .type-filter-box select,
            .folder-box select,
            .sort-box select {
                width: 100%;
                box-sizing: border-box;
            }

            .btn-group {
                justify-content: center;
            }

            .password-header {
                padding: 12px 16px;
            }

            .password-header h3 {
                font-size: 0.95rem;
            }

            .password-details {
                padding: 16px;
            }

            .pagination {
                flex-wrap: wrap;
                gap: 4px;
            }

            .pagination button {
                padding: 6px 10px;
                font-size: 13px;
                min-width: 36px;
            }

            .pagination-info {
                margin: 8px 0;
                width: 100%;
                text-align: center;
            }

            .modal-content {
                margin: 10% auto;
                width: 95%;
                padding: 20px;
            }

            /* Folders modal specific mobile optimizations */
            .folders-modal-content {
                max-width: none !important;
                margin: 5% auto;
                max-height: 85vh;
            }

            .folder-input-group {
                display: flex;
                flex-direction: column;
                gap: 12px;
            }

            .folder-input-group input {
                width: 100%;
                box-sizing: border-box;
            }

            .folder-input-group button {
                width: 100%;
                box-sizing: border-box;
            }

            /* Mobile folder list optimizations */
            .folder-item {
                padding: 12px 0 !important;
            }

            .folder-item input {
                font-size: 16px !important; /* Prevent zoom on iOS */
                margin-bottom: 8px !important;
            }

            .folder-button-group {
                gap: 6px !important;
            }

            .folder-button-group button {
                padding: 8px 12px !important;
                font-size: 13px !important;
                min-height: 36px; /* Minimum touch target */
            }

            /* Mobile optimizations for new action buttons layout */
            .password-field .value-actions {
                flex-direction: column;
                gap: 6px;
                align-items: stretch;
            }

            .password-field .value-actions .copy-btn {
                width: 100%;
                justify-content: center;
                padding: 8px 12px;
                font-size: 14px;
                min-height: 44px; /* Better touch target */
            }

            .password-field .value-content {
                padding: 12px 14px;
            }

            .password-field .value-content input {
                font-size: 16px; /* Prevent zoom on iOS */
            }
        }

        .export-import-section {
            background: #f9fafb;
            padding: 32px;
            border-radius: 16px;
            margin-top: 40px;
            border: 1px solid #e5e7eb;
        }

        .export-import-section h3 {
            margin-bottom: 12px;
            color: #111827;
            font-weight: 600;
            font-size: 1.125rem;
        }

        .export-import-section p {
            color: #6b7280;
            margin-bottom: 24px;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        .export-import-buttons {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .export-import-buttons .btn,
        .export-import-buttons .file-label {
            flex: 1;
            min-width: 160px;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .file-input {
            display: none;
        }

        .file-label {
            background: #1a1a1a;
            color: white;
            border: none;
        }

        .file-label:hover {
            background: #000000;
        }

        .loading {
            text-align: center;
            padding: 80px 24px;
            color: #6b7280;
        }

        .spinner {
            border: 2px solid #f3f4f6;
            border-top: 2px solid #1a1a1a;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        .initial-loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .initial-loading .loading-content {
            text-align: center;
            color: #6b7280;
        }

        .initial-loading h2 {
            margin-bottom: 16px;
            color: #1a1a1a;
            font-weight: 600;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin-top: 32px;
            padding: 20px 0;
        }

        .pagination button {
            background: #ffffff;
            border: 1px solid #d1d5db;
            color: #374151;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.15s ease;
            min-width: 40px;
            -webkit-app-region: no-drag; /* üö´ Buttons nicht drag-bar */
        }

        .pagination button:hover:not(:disabled) {
            background: #f9fafb;
            border-color: #9ca3af;
        }

        .pagination button.active {
            background: #1a1a1a;
            color: white;
            border-color: #1a1a1a;
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pagination-info {
            color: #6b7280;
            font-size: 14px;
            margin: 0 16px;
        }
    </style>
</head>
<body>
    <!-- App Version Display -->
    <div class="app-version" id="appVersion">v...</div>
    
    <!-- Top Action Buttons -->
    <div class="top-actions" id="topActions" style="display: none;">
        <button class="btn btn-fresh" onclick="showAddPasswordModal()">+ Neuer Eintrag</button>
        <button class="btn btn-fresh btn-secondary" id="manageFoldersBtn">Ordner verwalten</button>
        <button class="btn btn-fresh btn-logout" onclick="logout()">Logout</button>
        <!-- Session Timer Display -->
        <div id="sessionTimer" class="session-timer" style="display: none;">
            <div class="session-timer-content">
                <span class="session-timer-icon">‚è±Ô∏è</span>
                <span class="session-timer-text">Session: <span id="sessionTimeLeft">1:00</span></span>
            </div>
        </div>
    </div>
    
    <!-- Initial Loading Screen -->
    <div class="initial-loading" id="initialLoading">
        <div class="loading-content">
            <h2>Passwort Manager</h2>
            <div class="spinner"></div>
            <p>Pr√ºfe Session...</p>
        </div>
    </div>

    <div class="container">
        <div class="header">
        </div>

        <!-- Login Screen -->
        <div class="login-screen" id="loginScreen" style="display: none;">
            <div class="login-form">
                <h2 id="loginTitle">Master-Passwort eingeben</h2>
                <p id="loginDescription" style="margin: 20px 0; color: #7f8c8d;">
                    Geben Sie Ihr Master-Passwort ein, um auf Ihre verschl√ºsselten Passw√∂rter zuzugreifen.
                </p>
                <div id="sessionRecoveryNotice" style="display: none; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; padding: 12px; margin: 16px 0; color: #1976d2;">
                    <strong>üíæ Daten wiederhergestellt!</strong> Ihre Passw√∂rter und Ordner sind noch vorhanden. Geben Sie einfach Ihr Master-Passwort erneut ein.
                </div>
                <div class="form-group">
                    <label for="masterPassword">Master-Passwort:</label>
                    <input type="password" id="masterPassword" placeholder="Ihr Master-Passwort eingeben">
                </div>
                <button class="btn" onclick="login()" id="loginButton">Anmelden</button>
                <div style="margin-top: 20px; text-align: center;">
                    <button class="btn btn-secondary" onclick="showMasterPasswordManager()" style="width: auto; padding: 10px 20px;">
                        Master-Passw√∂rter verwalten
                    </button>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content" id="mainContent" style="display: none;">
                        <div class="toolbar">
                <!-- Zeile 1: Suchfeld + Type-Filter -->
                <div class="toolbar-row toolbar-row-1">
                    <div class="search-box">
                        <input type="text" id="searchInput" placeholder="Eintr√§ge durchsuchen...">
                        <span class="search-icon">‚åï</span>
                    </div>
                    
                    <!-- Type Filter - Desktop Version -->
                    <div class="type-filter-container desktop-only">
                        <div class="type-filter-buttons">
                            <button class="type-filter-btn active" data-type="all" onclick="passwordManager.filterByType('all')">
                                üóÇÔ∏è Alle Typen
                            </button>
                            <button class="type-filter-btn" data-type="password" onclick="passwordManager.filterByType('password')">
                                üîê Passw√∂rter
                            </button>
                            <button class="type-filter-btn" data-type="website" onclick="passwordManager.filterByType('website')">
                                üåê Webseiten
                            </button>
                            <button class="type-filter-btn" data-type="link" onclick="passwordManager.filterByType('link')">
                                üîó Links
                            </button>
                            <button class="type-filter-btn" data-type="note" onclick="passwordManager.filterByType('note')">
                                üìù Notizen
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Zeile 2: Dropdowns + Buttons (linksb√ºndig) -->
                <div class="toolbar-row toolbar-row-2">
                    <!-- Type Filter - Mobile Version: Tile Grid -->
                    <div class="type-filter-tiles mobile-only">
                        <button class="type-tile active" data-type="all" onclick="passwordManager.filterByType('all')">
                            üóÇÔ∏è<span>Alle</span>
                        </button>
                        <button class="type-tile" data-type="password" onclick="passwordManager.filterByType('password')">
                            üîê<span>Passw√∂rter</span>
                        </button>
                        <button class="type-tile" data-type="website" onclick="passwordManager.filterByType('website')">
                            üåê<span>Webseiten</span>
                        </button>
                        <button class="type-tile" data-type="link" onclick="passwordManager.filterByType('link')">
                            üîó<span>Links</span>
                        </button>
                        <button class="type-tile" data-type="note" onclick="passwordManager.filterByType('note')">
                            üìù<span>Notizen</span>
                        </button>
                    </div>
                    
                    <div class="folder-box">
                        <select id="folderSelect" aria-label="Ordnerfilter">
                            <option value="all">Alle Ordner</option>
                            <option value="null">Ohne Ordner</option>
                        </select>
                    </div>
                    
                    <div class="sort-box">
                        <select id="sortSelect" aria-label="Sortierung">
                            <option value="az">Titel A‚ÄìZ</option>
                            <option value="za">Titel Z‚ÄìA</option>
                        </select>
                    </div>
                    

                </div>
            </div>

            <!-- Drag & Drop Folder Bar -->
            <div id="folderDndBar" class="folder-dnd-bar" aria-label="Ordner Drop-Ziele"></div>

            <div id="passwordsContainer">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Lade Passw√∂rter...</p>
                </div>
            </div>

            <div class="export-import-section">
                <h3>Datenverwaltung</h3>
                <p>Exportieren Sie Ihre Passw√∂rter zur Sicherung oder importieren Sie sie von einem anderen Ger√§t.</p>
                <div class="export-import-buttons">
                    <button class="btn btn-success" onclick="exportData()">Alle Daten exportieren</button>
                    <label for="importFile" class="file-label">Daten importieren</label>
                    <input type="file" id="importFile" class="file-input" accept=".json" onchange="importData(event)">
                </div>
            </div>
        </div>
    </div>

    <!-- Add/Edit Entry Modal -->
    <div id="passwordModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('passwordModal')">&times;</span>
            <h2 id="modalTitle">Neues Passwort hinzuf√ºgen</h2>
            <form id="passwordForm">
                <!-- Entry Type Selection -->
                <div class="form-group">
                    <label for="entryType">Eintrag-Typ:</label>
                    <select id="entryType" onchange="toggleEntryTypeFields()">
                        <option value="password">üîê Passwort</option>
                        <option value="website">üåê Webseite</option>
                        <option value="link">üîó Link/Bookmark</option>
                        <option value="note">üìù Notiz</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="title">Titel:</label>
                    <input type="text" id="title" required>
                </div>
                
                <div class="form-group">
                    <label for="passwordFolder">Ordner (optional):</label>
                    <select id="passwordFolder">
                        <option value="">Ohne Ordner</option>
                    </select>
                </div>
                
                <!-- Password-specific fields -->
                <div id="passwordFields" class="entry-type-fields">
                    <div class="form-group">
                        <label for="username">Benutzername/E-Mail:</label>
                        <input type="text" id="username">
                    </div>
                    <div class="form-group">
                        <label for="password">Passwort:</label>
                        <div style="display:flex; gap:8px; align-items:center;">
                            <input type="password" id="password" style="flex:1;">
                            <button type="button" class="icon-btn" id="togglePasswordBtn" title="Sichtbarkeit umschalten" onclick="toggleModalPasswordVisibility()">üëÅÔ∏è</button>
                        </div>
                        <div class="strength-meter">
                            <div class="strength-bar" id="strengthBar"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Website/Link-specific fields -->
                <div id="linkFields" class="entry-type-fields" style="display: none;">
                    <div class="form-group">
                        <label for="url">URL:</label>
                        <input type="text" id="url" placeholder="https://example.com">
                    </div>
                </div>
                
                <!-- Note-specific fields -->
                <div id="noteFields" class="entry-type-fields" style="display: none;">
                    <div class="form-group">
                        <label for="content">Inhalt:</label>
                        <textarea id="content" rows="4" style="width: 100%; padding: 15px; border: 2px solid #e1e8ed; border-radius: 8px; font-size: 16px; resize: vertical;" placeholder="Ihr Notizinhalt..."></textarea>
                    </div>
                </div>
                
                <!-- Common fields -->
                <div class="form-group" id="urlFieldCommon" style="display: block;">
                    <label for="urlCommon">URL (optional):</label>
                    <input type="text" id="urlCommon" placeholder="example.com">
                </div>
                
                <div class="form-group">
                    <label for="notes">Notizen (optional):</label>
                    <textarea id="notes" rows="3" style="width: 100%; padding: 15px; border: 2px solid #e1e8ed; border-radius: 8px; font-size: 16px; resize: vertical;"></textarea>
                </div>
                
                <div class="btn-group">
                    <button type="button" class="btn btn-secondary" id="generatePasswordBtn" onclick="generatePassword()" style="display: block;">üîß Passwort generieren</button>
                    <button type="submit" class="btn">Speichern</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Master Password Manager Modal -->
    <div id="masterPasswordModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <span class="close" onclick="closeModal('masterPasswordModal')">&times;</span>
            <h2>üîë Master-Passw√∂rter verwalten</h2>
            
            <!-- Add new master password -->
            <div style="margin-bottom: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                <h3>Neues Master-Passwort hinzuf√ºgen</h3>
                <form id="masterPasswordForm">
                    <div class="form-group">
                        <label for="masterPasswordName">Name (optional):</label>
                        <input type="text" id="masterPasswordName" placeholder="z.B. Hauptzugang, Backup, etc.">
                    </div>
                    <div class="form-group">
                        <label for="newMasterPassword">Master-Passwort:</label>
                        <input type="password" id="newMasterPassword" placeholder="Mindestens 8 Zeichen" required>
                    </div>
                    <div class="form-group">
                        <label for="confirmNewMasterPassword">Passwort best√§tigen:</label>
                        <input type="password" id="confirmNewMasterPassword" placeholder="Passwort wiederholen" required>
                    </div>
                    <div class="form-group" id="existingMasterPasswordGroup" style="display:none;">
                        <label for="existingMasterPasswordConfirm">Bestehendes Master-Passwort (Best√§tigung):</label>
                        <input type="password" id="existingMasterPasswordConfirm" placeholder="Aktuelles Master-Passwort eingeben">
                        <small style="color:#6b7280;">Erforderlich, wenn bereits Master-Passw√∂rter existieren.</small>
                    </div>
                    <div class="form-group">
                        <label for="newMasterPasswordHint">Passworthilfe (optional):</label>
                        <input type="text" id="newMasterPasswordHint" placeholder="Ein Hinweis, der das Passwort nicht verr√§t">
                    </div>
                    <button type="submit" class="btn">Hinzuf√ºgen</button>
                </form>
            </div>

            <!-- List existing master passwords -->
            <div>
                <h3>Vorhandene Master-Passw√∂rter</h3>
                <div id="masterPasswordsList">
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Lade Master-Passw√∂rter...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div id="notification" class="notification"></div>

    <!-- Generic Confirm/Prompt Modal -->
    <div id="confirmModal" class="modal">
        <div class="modal-content" style="max-width: 460px;">
            <span class="close" onclick="closeModal('confirmModal')">&times;</span>
            <h2 id="confirmTitle">Best√§tigen</h2>
            <p id="confirmMessage" style="margin-bottom:16px; color:#374151;"></p>
            <div id="confirmPasswordGroup" class="form-group" style="display:none;">
                <label for="confirmPasswordInput" id="confirmPasswordLabel">Zur Best√§tigung Master-Passwort eingeben:</label>
                <input type="password" id="confirmPasswordInput" placeholder="Master-Passwort">
            </div>
            <div id="confirmPassword2Group" class="form-group" style="display:none;">
                <label for="confirmPassword2Input" id="confirmPassword2Label">Passwort wiederholen:</label>
                <input type="password" id="confirmPassword2Input" placeholder="Passwort wiederholen">
            </div>
            <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:16px;">
                <button id="confirmCancelBtn" class="btn btn-secondary" style="width:auto;">Abbrechen</button>
                <button id="confirmOkBtn" class="btn" style="width:auto;">OK</button>
            </div>
        </div>
    </div>

    <!-- Folders Modal -->
    <div id="foldersModal" class="modal">
        <div class="modal-content folders-modal-content">
            <span class="close" onclick="closeModal('foldersModal')">&times;</span>
            <h2>üìÅ Ordner verwalten</h2>
            <div class="form-group" style="margin-bottom: 16px;">
                <label for="newFolderName">Neuer Ordnername:</label>
                <div class="folder-input-group">
                    <input type="text" id="newFolderName" placeholder="z.B. E-Mail, Banking, Arbeit">
                    <button class="btn" id="createFolderBtn">Hinzuf√ºgen</button>
                </div>
            </div>
            <div id="foldersList"></div>
        </div>
    </div>

    <script>
        // Register Service Worker for PWA (best-effort)
        if ('serviceWorker' in navigator) {
            try {
                navigator.serviceWorker.register('service-worker.js', { scope: '/passwortmanager-pwa/' }).catch(() => {});
            } catch (e) {
                // no-op
            }
        }
        let uiEventsBound = false;
        let toastTimer = null;

        const showToast = (message, type = 'success') => {
            const notification = document.getElementById('notification');
            if (!notification) return;
            notification.textContent = message;
            notification.className = `notification ${type}`;
            // Force reflow to restart CSS transition if needed
            // eslint-disable-next-line no-unused-expressions
            notification.offsetHeight;
            notification.classList.add('show');
            if (toastTimer) clearTimeout(toastTimer);
            toastTimer = setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        };

        // ---------- Local Mode (IndexedDB + WebCrypto) helpers ----------
        const textEncoder = new TextEncoder();
        const textDecoder = new TextDecoder();

        const toHex = (buf) => Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
        const fromHex = (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))).buffer;

        const deriveAesKeyFromString = async (keyString, saltBytes) => {
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                textEncoder.encode(keyString),
                'PBKDF2',
                false,
                ['deriveKey']
            );
            const key = await crypto.subtle.deriveKey(
                { name: 'PBKDF2', salt: saltBytes, iterations: 100000, hash: 'SHA-256' },
                keyMaterial,
                { name: 'AES-CBC', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
            return key;
        };

        const pbkdf2HashHex = async (password, saltBytes, byteLength = 64) => {
            const keyMaterial = await crypto.subtle.importKey('raw', textEncoder.encode(password), 'PBKDF2', false, ['deriveBits']);
            const bits = await crypto.subtle.deriveBits(
                { name: 'PBKDF2', salt: saltBytes, iterations: 100000, hash: 'SHA-256' },
                keyMaterial,
                byteLength * 8
            );
            return toHex(bits);
        };

        const encryptStringAesCbc = async (plaintext, key) => {
            const iv = crypto.getRandomValues(new Uint8Array(16));
            const enc = await crypto.subtle.encrypt({ name: 'AES-CBC', iv }, key, textEncoder.encode(plaintext));
            return { encrypted: toHex(enc), iv: toHex(iv) };
        };

        const decryptStringAesCbc = async (encryptedHex, ivHex, key) => {
            const data = fromHex(encryptedHex);
            const iv = new Uint8Array(fromHex(ivHex));
            const dec = await crypto.subtle.decrypt({ name: 'AES-CBC', iv }, key, data);
            return textDecoder.decode(dec);
        };

        const wrapDataKeyForPassword = async (password, saltHex, dataKeyHex) => {
            const saltBytes = new Uint8Array(fromHex(saltHex));
            const wrapperKey = await deriveAesKeyFromString(password, saltBytes);
            const { encrypted, iv } = await encryptStringAesCbc(dataKeyHex, wrapperKey);
            return { wrappedDataKey: encrypted, wrapIv: iv };
        };

        const unwrapDataKeyWithPassword = async (password, saltHex, wrappedDataKeyHex, wrapIvHex) => {
            const saltBytes = new Uint8Array(fromHex(saltHex));
            const wrapperKey = await deriveAesKeyFromString(password, saltBytes);
            const dataKeyHex = await decryptStringAesCbc(wrappedDataKeyHex, wrapIvHex, wrapperKey);
            return dataKeyHex;
        };

        const openLocalDb = () => new Promise((resolve, reject) => {
            const req = indexedDB.open('passwortmanager', 1);
            req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('meta')) db.createObjectStore('meta', { keyPath: 'key' });
            };
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
        });

        const idbGet = async (key) => {
            const db = await openLocalDb();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('meta', 'readonly');
                const store = tx.objectStore('meta');
                const g = store.get(key);
                g.onsuccess = () => resolve(g.result ? g.result.value : null);
                g.onerror = () => reject(g.error);
            });
        };

        const idbSet = async (key, value) => {
            const db = await openLocalDb();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('meta', 'readwrite');
                const store = tx.objectStore('meta');
                store.put({ key, value });
                tx.oncomplete = () => resolve(true);
                tx.onerror = () => reject(tx.error);
            });
        };

        const ENCRYPTION_SCHEME = 'dataKey-v1';

        const LocalMode = {
            getMasterPasswords: async () => {
                return (await idbGet('masterPasswords')) || [];
            },
            saveMasterPasswords: async (list) => {
                await idbSet('masterPasswords', list || []);
            },
            getVaultEncrypted: async () => {
                return (await idbGet('vault')) || null; // {encrypted, iv, salt, scheme}
            },
            saveVaultEncrypted: async (payload) => {
                await idbSet('vault', payload);
            },
            loadVault: async (dataKeyHex) => {
                const enc = await LocalMode.getVaultEncrypted();
                if (!enc || !enc.encrypted) return { passwords: [], folders: [], encryptionScheme: ENCRYPTION_SCHEME };
                const saltBytes = new Uint8Array(fromHex(enc.salt));
                const key = await deriveAesKeyFromString(dataKeyHex, saltBytes);
                const json = await decryptStringAesCbc(enc.encrypted, enc.iv, key);
                const obj = JSON.parse(json || '{}');
                obj.passwords = Array.isArray(obj.passwords) ? obj.passwords : [];
                obj.folders = Array.isArray(obj.folders) ? obj.folders : [];
                return obj;
            },
            saveVault: async (dataKeyHex, vaultObj) => {
                const salt = crypto.getRandomValues(new Uint8Array(16));
                const key = await deriveAesKeyFromString(dataKeyHex, salt);
                const { encrypted, iv } = await encryptStringAesCbc(JSON.stringify(vaultObj || {}), key);
                await LocalMode.saveVaultEncrypted({ encrypted, iv, salt: toHex(salt), scheme: ENCRYPTION_SCHEME });
            },
        };

        class PasswordManager {
            constructor() {
                this.passwords = [];
                this.masterPassword = '';
                this.currentMasterPassword = null;
                this.isAuthenticated = false;
                this.modeChecked = false;
                this.localMode = false;
                this.dataKeyHex = null; // Local Mode only
                // Support file:// fallback by reading ?port= from query
                try {
                    const params = new URLSearchParams(window.location.search);
                    const port = params.get('port');
                    this.apiBase = port ? `http://localhost:${port}/api` : '/api';
                } catch (_) {
                    this.apiBase = '/api';
                }
                this.currentPage = 1;
                this.itemsPerPage = 25;
                this.sortOrder = 'az';
                this.folders = [];
                this.selectedFolderId = 'all';
                this.selectedEntryType = 'all'; // Default to show all entry types
                this.cachedMasterPassword = null; // Will be loaded in init()
                this.sessionTimer = null; // for countdown display
                this.sessionWarningShown = false;
                this.init();
            }

            init() {
                // Load cached password on initialization
                this.loadCachedPasswordOnInit();
                this.setupEventListeners();
                
                // Load app version
                this.loadAppVersion();
            }

            loadCachedPasswordOnInit() {
                try {
                    const cached = sessionStorage.getItem('pwa_cached_mp');
                    const timestamp = sessionStorage.getItem('pwa_session_timestamp');
                    
                    console.log('üîç Loading cached password on init:', { 
                        hasCached: !!cached, 
                        hasTimestamp: !!timestamp,
                        timestamp: timestamp 
                    });
                    
                    if (cached && timestamp) {
                        const age = Date.now() - parseInt(timestamp);
                        const maxAge = 30 * 60 * 1000; // 30 minutes
                        
                        console.log('üìÖ Cache age check:', { 
                            age: Math.round(age / 1000), 
                            maxAge: Math.round(maxAge / 1000),
                            valid: age <= maxAge 
                        });
                        
                        if (age <= maxAge) {
                            this.cachedMasterPassword = atob(cached);
                            console.log('‚úÖ Cached password loaded successfully on init');
                        } else {
                            // Clear expired cache
                            sessionStorage.removeItem('pwa_cached_mp');
                            sessionStorage.removeItem('pwa_session_timestamp');
                            console.log('üóëÔ∏è Cleared expired cache');
                        }
                    } else {
                        console.log('‚ùå No cached password found on init');
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Could not load cached password on init:', error);
                }
            }

            async ensureMode() {
                if (this.modeChecked) return;
                
                // Force LOCAL mode for now to avoid server authentication issues
                this.localMode = true;
                console.log('üîß Forced LOCAL mode - using browser localStorage');
                
                this.modeChecked = true;
            }

            setupEventListeners() {
                if (uiEventsBound) return;

                // Search functionality
                const searchInput = document.getElementById('searchInput');
                if (searchInput) {
                    searchInput.addEventListener('input', (e) => {
                        if (passwordManager) passwordManager.filterPasswords(e.target.value);
                    });
                }

                // Password form
                const passwordForm = document.getElementById('passwordForm');
                if (passwordForm) {
                    passwordForm.addEventListener('submit', (e) => {
                        e.preventDefault();
                        if (passwordManager) passwordManager.savePassword();
                    });
                }

                // Password strength meter
                const passwordInput = document.getElementById('password');
                if (passwordInput) {
                    passwordInput.addEventListener('input', (e) => {
                        if (passwordManager) passwordManager.updatePasswordStrength(e.target.value);
                    });
                }

                // Enter key for login
                const masterPwInput = document.getElementById('masterPassword');
                if (masterPwInput) {
                    masterPwInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') login();
                    });
                }

                // Sorting
                const sortSelect = document.getElementById('sortSelect');
                if (sortSelect) {
                    sortSelect.addEventListener('change', (e) => {
                        if (!passwordManager) return;
                        passwordManager.sortOrder = e.target.value;
                        passwordManager.renderPasswords();
                    });
                }

                // Folder filter
                const folderSelect = document.getElementById('folderSelect');
                if (folderSelect) {
                    folderSelect.addEventListener('change', (e) => {
                        if (!passwordManager) return;
                        passwordManager.selectedFolderId = e.target.value;
                        passwordManager.currentPage = 1;
                        passwordManager.renderPasswords();
                    });
                }

                // Manage folders modal
                const manageBtn = document.getElementById('manageFoldersBtn');
                if (manageBtn) {
                    manageBtn.addEventListener('click', () => {
                        document.getElementById('foldersModal').style.display = 'block';
                        if (passwordManager) passwordManager.renderFoldersList();
                    });
                }

                // Create folder button in modal
                const createBtn = document.getElementById('createFolderBtn');
                if (createBtn) {
                    createBtn.addEventListener('click', async (e) => {
                        e.preventDefault();
                        if (createBtn.dataset.loading === '1') return;
                        const input = document.getElementById('newFolderName');
                        const name = (input?.value || '').trim();
                        if (!name || !passwordManager) return;
                        try {
                            createBtn.dataset.loading = '1';
                            createBtn.disabled = true;
                            await passwordManager.createFolder(name);
                            input.value = '';
                            // No need to call renderFoldersList() here as createFolder() already handles UI updates
                        } finally {
                            createBtn.disabled = false;
                            delete createBtn.dataset.loading;
                        }
                    });
                }

                uiEventsBound = true;
            }

            normalizeUrl = (raw) => {
                const input = String(raw || '').trim();
                if (!input) return '';
                if (/^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//.test(input)) return input;
                if (input.startsWith('www.')) return `https://${input}`;
                if (/^(localhost(?::\d+)?|\d{1,3}(?:\.\d{1,3}){3}(?::\d+)?)/.test(input)) {
                    return `http://${input}`;
                }
                if (/^[^\s@]+\.[^\s@]{2,}/.test(input)) return `https://${input}`;
                return input;
            }

            async savePassword() {
                const entryType = document.getElementById('entryType').value;
                
                const formData = {
                    type: entryType,
                    title: document.getElementById('title').value.trim(),
                    notes: document.getElementById('notes').value.trim(),
                    folderId: document.getElementById('passwordFolder') ? (document.getElementById('passwordFolder').value || null) : null
                };

                // Validate basic fields
                if (!formData.title) {
                    alert('Bitte geben Sie einen Titel ein.');
                    return;
                }

                // Add type-specific fields and validation
                switch(entryType) {
                    case 'password':
                        formData.username = document.getElementById('username').value.trim();
                        formData.password = document.getElementById('password').value;
                        formData.url = this.normalizeUrl(document.getElementById('urlCommon').value);
                        
                        if (!formData.username || !formData.password) {
                            alert('Bitte f√ºllen Sie Benutzername und Passwort aus.');
                            return;
                        }
                        break;
                        
                    case 'website':
                    case 'link':
                        formData.url = this.normalizeUrl(document.getElementById('url').value);
                        
                        if (!formData.url) {
                            alert('Bitte geben Sie eine URL ein.');
                            return;
                        }
                        break;
                        
                    case 'note':
                        formData.content = document.getElementById('content').value.trim();
                        formData.url = this.normalizeUrl(document.getElementById('urlCommon').value);
                        
                        if (!formData.content) {
                            alert('Bitte geben Sie einen Inhalt f√ºr die Notiz ein.');
                            return;
                        }
                        break;
                }

                if (currentEditingId) {
                    await this.updateEntry(currentEditingId, formData);
                } else {
                    await this.addEntry(formData);
                }

                closeModal('passwordModal');
            }

            async ensureAuthenticatedOrReLogin() {
                try {
                    // If session is valid, nothing to do
                    const ok = await this.checkSessionStatus();
                    if (ok) return true;
                } catch (error) {
                    console.error('Error checking session status during re-login:', error);
                }
                
                // Try transparent re-login using cached password (memory only)
                // Try to get cached password if not in memory
                if (!this.cachedMasterPassword) {
                    this.cachedMasterPassword = this.getCachedPassword();
                }
                
                if (!this.cachedMasterPassword) {
                    console.log('No cached master password available for re-login');
                    return false;
                }
                
                try {
                    console.log('Attempting transparent re-login...');
                    await this.verifyMasterPassword(this.cachedMasterPassword);
                    
                    // Reinitialize activity tracking after successful re-login
                    this.initActivityTracking();
                    
                    // Restart session timer
                    this.startSessionTimer();
                    
                    // Give the server a moment to save session to store
                    await new Promise(r => setTimeout(r, 25));
                    console.log('Transparent re-login successful');
                    return true;
                } catch (error) {
                    console.error('Error during transparent re-login:', error);
                    // Clear cached password if re-login fails
                    this.clearCachedPassword();
                    return false;
                }
            }

            async fetchWithAuthRetry(url, init) {
                try {
                    const res = await fetch(url, init);
                    if (res.status !== 401) return res;
                    
                    // Attempt re-login once
                    const relogged = await this.ensureAuthenticatedOrReLogin();
                    if (!relogged) {
                        // If re-login failed, return the original response
                        return res;
                    }
                    
                    // Try the request again with the new session
                    try {
                        return await fetch(url, init);
                    } catch (retryError) {
                        console.error('Error during retry request:', retryError);
                        // Return the original response if retry fails
                        return res;
                    }
                } catch (error) {
                    console.error('Error in fetchWithAuthRetry:', error);
                    // Create a mock response for the error case
                    return new Response(JSON.stringify({ error: 'Network error' }), {
                        status: 500,
                        headers: { 'Content-Type': 'application/json' }
                    });
                }
            }

            async checkSessionStatus() {
                try {
                    await this.ensureMode();
                    if (this.localMode) {
                        return this.isAuthenticated;
                    }
                    
                    const response = await fetch(`${this.apiBase}/session-status`, {
                        credentials: 'include'
                    });
                    
                    if (!response.ok) {
                        console.warn('Session status check failed with status:', response.status);
                        return false;
                    }
                    
                    const data = await response.json();
                    
                    // Log session info for debugging
                    if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'development') {
                        console.log('Session status:', data);
                    }
                    
                    // Store session recovery info for UI
                    this.sessionRecoverable = data.sessionRecoverable || false;
                    
                    return data.authenticated || false;
                } catch (error) {
                    console.error('Error checking session status:', error);
                    return false;
                }
            }

            // Initialize activity tracking for session extension
            initActivityTracking() {
                if (this.localMode) return;
                
                // Track various user activities
                const activityEvents = ['click', 'keydown', 'mousemove', 'scroll', 'touchstart'];
                let lastActivityTime = Date.now();
                
                const handleActivity = () => {
                    const now = Date.now();
                    // Only track activity if it's been more than 10 seconds since last track
                    // This prevents excessive API calls
                    if (now - lastActivityTime > 10000) {
                        lastActivityTime = now;
                        this.extendSession();
                        this.resetSessionTimer(); // Reset timer on activity
                    }
                };
                
                // Add event listeners for activity tracking
                activityEvents.forEach(event => {
                    document.addEventListener(event, handleActivity, { passive: true });
                });
                
                console.log('Activity tracking initialized for session extension');
            }

            // Extend session on user activity
            async extendSession() {
                if (this.localMode || !this.isAuthenticated) return;
                
                try {
                    // Simple API call to extend session - the middleware will handle the extension
                    const response = await fetch(`${this.apiBase}/session-status`, {
                        credentials: 'include'
                    });
                    
                    if (response.ok) {
                        console.log('Session extended successfully');
                    } else if (response.status === 401) {
                        console.warn('Session extension failed - session may have expired');
                        // Try transparent re-login
                        const relogged = await this.ensureAuthenticatedOrReLogin();
                        if (!relogged) {
                            console.warn('Re-login failed, user may need to manually log in again');
                        }
                    }
                } catch (error) {
                    console.error('Error extending session:', error);
                }
            }

            // Secure password caching for session persistence
            setCachedPassword(password) {
                if (!password) {
                    console.warn('‚ö†Ô∏è Tried to cache empty password');
                    return;
                }
                try {
                    // Store encrypted in sessionStorage (survives refresh, not tab close)
                    const timestamp = Date.now().toString();
                    sessionStorage.setItem('pwa_cached_mp', btoa(password));
                    sessionStorage.setItem('pwa_session_timestamp', timestamp);
                    
                    // Also store in localStorage as backup (survives browser restart)
                    localStorage.setItem('pwa_cached_mp_backup', btoa(password));
                    localStorage.setItem('pwa_session_timestamp_backup', timestamp);
                    
                    console.log('üíæ Password cached for session persistence:', {
                        timestamp: timestamp,
                        cachedLength: password.length,
                        sessionStorageSize: sessionStorage.length,
                        localStorageBackup: true
                    });
                } catch (error) {
                    console.warn('‚ö†Ô∏è Could not cache password:', error);
                }
            }

            getCachedPassword() {
                try {
                    // Try sessionStorage first (survives page refresh)
                    let cached = sessionStorage.getItem('pwa_cached_mp');
                    let timestamp = sessionStorage.getItem('pwa_session_timestamp');
                    
                    // If not found in sessionStorage, try localStorage backup
                    if (!cached || !timestamp) {
                        cached = localStorage.getItem('pwa_cached_mp_backup');
                        timestamp = localStorage.getItem('pwa_session_timestamp_backup');
                        
                        // If found in localStorage, restore to sessionStorage for next time
                        if (cached && timestamp) {
                            sessionStorage.setItem('pwa_cached_mp', cached);
                            sessionStorage.setItem('pwa_session_timestamp', timestamp);
                            console.log('üîÑ Restored cached password from localStorage backup');
                        }
                    }
                    
                    if (!cached || !timestamp) return null;
                    
                    // Check if cache is not older than 1 minute (for testing)
                    const age = Date.now() - parseInt(timestamp);
                    const maxAge = 1 * 60 * 1000; // 1 minute
                    
                    if (age > maxAge) {
                        this.clearCachedPassword();
                        return null;
                    }
                    
                    return atob(cached);
                } catch (error) {
                    console.warn('Could not retrieve cached password:', error);
                    return null;
                }
            }

            clearCachedPassword() {
                try {
                    sessionStorage.removeItem('pwa_cached_mp');
                    sessionStorage.removeItem('pwa_session_timestamp');
                    localStorage.removeItem('pwa_cached_mp_backup');
                    localStorage.removeItem('pwa_session_timestamp_backup');
                    this.cachedMasterPassword = null;
                    console.log('üóëÔ∏è Cleared all cached passwords');
                } catch (error) {
                    console.warn('Could not clear cached password:', error);
                }
            }

            // Session countdown timer like banking apps
            startSessionTimer() {
                // Now works for both local and server mode
                this.stopSessionTimer(); // Clear any existing timer
                
                const sessionDuration = 1 * 60 * 1000; // 1 minute in ms (for testing)
                const warningTime = 30 * 1000; // Show warning 30 seconds before
                
                this.sessionDuration = sessionDuration; // Store for reset
                this.timeRemaining = sessionDuration;
                this.lastActivityTime = Date.now(); // Track last activity
                
                this.sessionTimer = setInterval(() => {
                    this.timeRemaining -= 1000;
                    
                    // Update session display every second
                    this.updateSessionDisplay();
                    
                    // Show warning when 30 seconds left
                    if (this.timeRemaining <= warningTime && !this.sessionWarningShown) {
                        this.showSessionWarning(Math.ceil(this.timeRemaining / 1000));
                        this.sessionWarningShown = true;
                    }
                    
                    // Update timer display if warning is shown
                    if (this.sessionWarningShown) {
                        this.updateSessionWarning(Math.ceil(this.timeRemaining / 1000));
                    }
                    
                    // Session expired
                    if (this.timeRemaining <= 0) {
                        this.handleSessionTimeout();
                    }
                }, 1000);
                
                console.log('Session timer started (1 minute for testing)');
                this.showSessionIndicator();
                
                // Set up activity tracking to reset timer
                this.setupActivityTracking();
            }

            stopSessionTimer() {
                if (this.sessionTimer) {
                    clearInterval(this.sessionTimer);
                    this.sessionTimer = null;
                }
                this.sessionWarningShown = false;
                this.hideSessionWarning();
                this.hideSessionIndicator();
            }

            resetSessionTimer() {
                if (this.isAuthenticated) {
                    // Reset the timer to full duration on activity
                    this.timeRemaining = this.sessionDuration;
                    this.lastActivityTime = Date.now();
                    this.sessionWarningShown = false;
                    this.hideSessionWarning();
                    
                    // Update cache timestamp to extend auto-login
                    this.updateCacheTimestamp();
                    
                    console.log('Session timer reset to 1 minute due to activity');
                }
            }
            
            // Update cache timestamp to extend auto-login duration
            updateCacheTimestamp() {
                try {
                    const timestamp = Date.now().toString();
                    if (sessionStorage.getItem('pwa_cached_mp')) {
                        sessionStorage.setItem('pwa_session_timestamp', timestamp);
                    }
                    if (localStorage.getItem('pwa_cached_mp_backup')) {
                        localStorage.setItem('pwa_session_timestamp_backup', timestamp);
                    }
                } catch (error) {
                    console.warn('Could not update cache timestamp:', error);
                }
            }
            
            // Setup activity tracking for timer reset
            setupActivityTracking() {
                if (this.activityListenersSetup) return; // Avoid duplicate listeners
                
                const activityEvents = ['click', 'keydown', 'mousemove', 'scroll', 'touchstart', 'focus'];
                const resetTimer = () => {
                    // Throttle resets to once per 5 seconds to avoid excessive updates
                    const now = Date.now();
                    if (now - this.lastActivityTime > 5000) { // 5 second throttle
                        this.resetSessionTimer();
                    }
                };
                
                activityEvents.forEach(event => {
                    document.addEventListener(event, resetTimer, { passive: true });
                });
                
                this.activityListenersSetup = true;
                console.log('Activity tracking setup for session timer reset');
            }

            showSessionWarning(secondsLeft) {
                // Create or update session warning modal
                let modal = document.getElementById('sessionWarningModal');
                if (!modal) {
                    modal = document.createElement('div');
                    modal.id = 'sessionWarningModal';
                    modal.innerHTML = `
                        <div class="modal-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;">
                            <div class="modal-content" style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); max-width: 400px; text-align: center;">
                                <h3 style="color: #d32f2f; margin-bottom: 15px;">‚ö†Ô∏è Session l√§uft ab</h3>
                                <p id="sessionTimeLeft" style="margin-bottom: 20px;">Ihre Sitzung l√§uft in <span id="timeCounter">${secondsLeft}</span> Sekunden ab.</p>
                                <div style="display: flex; gap: 10px; justify-content: center;">
                                    <button id="extendSessionBtn" class="btn btn-primary" style="background: #1976d2; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Session verl√§ngern</button>
                                    <button id="logoutNowBtn" class="btn btn-secondary" style="background: #757575; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Jetzt abmelden</button>
                                </div>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(modal);
                    
                    // Event listeners
                    document.getElementById('extendSessionBtn').addEventListener('click', () => {
                        this.extendSession();
                        this.hideSessionWarning();
                        this.resetSessionTimer();
                        this.sessionWarningShown = false;
                    });
                    
                    document.getElementById('logoutNowBtn').addEventListener('click', () => {
                        this.logout();
                    });
                }
            }

            updateSessionWarning(secondsLeft) {
                const counter = document.getElementById('timeCounter');
                if (counter) {
                    counter.textContent = secondsLeft;
                }
            }

            hideSessionWarning() {
                const modal = document.getElementById('sessionWarningModal');
                if (modal) {
                    modal.remove();
                }
                this.sessionWarningShown = false;
            }

            showSessionIndicator() {
                // Show the elegant timer display under logout button
                const sessionTimer = document.getElementById('sessionTimer');
                const sessionTimeLeft = document.getElementById('sessionTimeLeft');
                
                if (sessionTimer && sessionTimeLeft) {
                    sessionTimer.style.display = 'block';
                    this.updateSessionDisplay();
                }
            }
            
            updateSessionDisplay() {
                const sessionTimeLeft = document.getElementById('sessionTimeLeft');
                const sessionTimer = document.getElementById('sessionTimer');
                
                if (!sessionTimeLeft || !sessionTimer) return;
                
                // If timeRemaining is not set, show default
                if (!this.timeRemaining || this.timeRemaining <= 0) {
                    sessionTimeLeft.textContent = '1:00';
                    return;
                }
                
                const minutes = Math.floor(this.timeRemaining / 60000);
                const seconds = Math.floor((this.timeRemaining % 60000) / 1000);
                const timeText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                sessionTimeLeft.textContent = timeText;
                
                // Update visual states based on remaining time
                sessionTimer.classList.remove('warning', 'critical');
                
                if (this.timeRemaining <= 10000) { // Last 10 seconds - critical
                    sessionTimer.classList.add('critical');
                } else if (this.timeRemaining <= 30000) { // Last 30 seconds - warning
                    sessionTimer.classList.add('warning');
                }
                
                console.log(`Timer updated: ${timeText} (${this.timeRemaining}ms remaining)`);
            }

            hideSessionIndicator() {
                const sessionTimer = document.getElementById('sessionTimer');
                if (sessionTimer) {
                    sessionTimer.style.display = 'none';
                }
            }

            handleSessionTimeout() {
                console.log('Session timeout - logging out user');
                this.stopSessionTimer();
                this.hideSessionWarning();
                this.hideSessionIndicator(); // Hide the timer display
                this.clearCachedPassword();
                
                // Force logout and redirect to login screen immediately
                this.isAuthenticated = false;
                this.masterPassword = null;
                this.currentMasterPassword = null;
                
                // Reset UI immediately
                document.getElementById('mainContent').style.display = 'none';
                document.getElementById('topActions').style.display = 'none';
                document.getElementById('loginScreen').style.display = 'block';
                
                console.log('User automatically logged out due to session timeout');
            }

            logout() {
                this.stopSessionTimer();
                this.hideSessionIndicator(); // Hide the timer display
                this.clearCachedPassword();
                this.isAuthenticated = false;
                this.masterPassword = null;
                this.currentMasterPassword = null;
                
                // Reset UI
                document.getElementById('mainContent').style.display = 'none';
                document.getElementById('topActions').style.display = 'none';
                document.getElementById('loginScreen').style.display = 'block';
                
                console.log('User logged out');
            }

            // Load app version from package.json via API or use constant
            async loadAppVersion() {
                const versionElement = document.getElementById('appVersion');
                if (!versionElement) return;
                
                try {
                    await this.ensureMode();
                    
                    if (this.localMode) {
                        // In local mode, use the APP_VERSION constant
                        versionElement.textContent = `v${APP_VERSION}`;
                        console.log(`üì¶ App version (local): v${APP_VERSION}`);
                        return;
                    }
                    
                    // Try to load version from API in server mode
                    const response = await fetch(`${this.apiBase}/version`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.version) {
                            versionElement.textContent = `v${data.version}`;
                            console.log(`üì¶ App version (server): v${data.version}`);
                            return;
                        }
                    }
                    
                    throw new Error('Version API not available');
                } catch (error) {
                    console.warn('Could not load app version from server, using constant:', error);
                    // Fallback to constant
                    versionElement.textContent = `v${APP_VERSION}`;
                    console.log(`üì¶ App version (fallback): v${APP_VERSION}`);
                }
            }

            async checkMasterPasswordStatus() {
                await this.ensureMode();
                if (this.localMode) {
                    const list = await LocalMode.getMasterPasswords();
                    return Array.isArray(list) && list.length > 0;
                }
                try {
                    const response = await fetch(`${this.apiBase}/master-password-status`);
                    if (!response.ok) {
                        throw new Error('Failed to check master password status');
                    }
                    const data = await response.json();
                    return data.masterPasswordSet;
                } catch (error) {
                    console.error('Error checking master password status:', error);
                    return false;
                }
            }

            async addMasterPassword(password, name, hint = '') {
                await this.ensureMode();
                if (this.localMode) {
                    const list = await LocalMode.getMasterPasswords();
                    if (list.length > 0) {
                        // Need confirming existing password
                        const confirming = this.confirmingPasswordForNew;
                        if (!confirming) throw new Error('Confirmation with an existing master password is required');
                        // Find matching entry to unwrap existing dataKey
                        let matched = null;
                        for (const mp of list) {
                            const saltBytes = new Uint8Array(fromHex(mp.salt));
                            const hash = await pbkdf2HashHex(confirming, saltBytes, 64);
                            if (hash === mp.hashedPassword) { matched = mp; break; }
                        }
                        if (!matched || !matched.wrappedDataKey || !matched.wrapIv) throw new Error('Invalid confirmation master password');
                        const dataKeyHex = await unwrapDataKeyWithPassword(confirming, matched.salt, matched.wrappedDataKey, matched.wrapIv);
                        const salt = crypto.getRandomValues(new Uint8Array(16));
                        const hashedPassword = await pbkdf2HashHex(password, salt, 64);
                        const { wrappedDataKey, wrapIv } = await wrapDataKeyForPassword(password, toHex(salt), dataKeyHex);
                        const newEntry = { id: crypto.randomUUID(), name: name || 'Master Password', hint: String(hint || ''), hashedPassword, salt: toHex(salt), createdAt: new Date().toISOString(), wrappedDataKey, wrapIv, isPrimary: false };
                        list.push(newEntry);
                        await LocalMode.saveMasterPasswords(list);
                        this.dataKeyHex = dataKeyHex;
                        this.isAuthenticated = true;
                        return { masterPassword: { name: newEntry.name } };
                    }
                    // First password
                    const salt = crypto.getRandomValues(new Uint8Array(16));
                    const hashedPassword = await pbkdf2HashHex(password, salt, 64);
                    const dataKeyHex = Array.from(crypto.getRandomValues(new Uint8Array(32))).map(b=>b.toString(16).padStart(2,'0')).join('');
                    const { wrappedDataKey, wrapIv } = await wrapDataKeyForPassword(password, toHex(salt), dataKeyHex);
                    const created = { id: crypto.randomUUID(), name: name || 'Master Password', hint: String(hint || ''), hashedPassword, salt: toHex(salt), createdAt: new Date().toISOString(), wrappedDataKey, wrapIv, isPrimary: true };
                    await LocalMode.saveMasterPasswords([created]);
                    // Initialize empty vault
                    await LocalMode.saveVault(dataKeyHex, { passwords: [], folders: [], encryptionScheme: ENCRYPTION_SCHEME });
                    this.dataKeyHex = dataKeyHex;
                    this.isAuthenticated = true;
                    return { masterPassword: { name: created.name } };
                }
                try {
                    const response = await fetch(`${this.apiBase}/add-master-password`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        credentials: 'include',
                        body: JSON.stringify({ password, name, hint, confirmingPassword: this.confirmingPasswordForNew || undefined })
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        const err = new Error(error.error || 'Failed to add master password');
                        
                        // Handle specific error codes
                        if (error.code === 'SESSION_CREATION_FAILED') {
                            err.message = 'Fehler beim Erstellen der Sitzung. Bitte versuchen Sie es erneut.';
                        }
                        
                        throw err;
                    }

                    const result = await response.json();
                    // If this is the first login, set authentication
                    if (!this.isAuthenticated) {
                        this.masterPassword = password;
                        this.currentMasterPassword = result.masterPassword;
                        this.isAuthenticated = true;
                        
                        // Cache the password for transparent re-login
                        this.cachedMasterPassword = password;
                    }
                    return result;
                } catch (error) {
                    throw error;
                }
            }

            async removeMasterPassword(id, confirmingPassword) {
                await this.ensureMode();
                if (this.localMode) {
                    const list = await LocalMode.getMasterPasswords();
                    const mp = list.find(m => m.id === id);
                    if (!mp) throw new Error('Master password not found');
                    const hash = await pbkdf2HashHex(confirmingPassword, new Uint8Array(fromHex(mp.salt)), 64);
                    if (hash !== mp.hashedPassword) throw new Error('Invalid master password');
                    const filtered = list.filter(m => m.id !== id);
                    await LocalMode.saveMasterPasswords(filtered);
                    // If no passwords left, optionally clear session
                    if (filtered.length === 0) {
                        this.isAuthenticated = false;
                        this.dataKeyHex = null;
                    }
                    return { message: 'Master password removed successfully' };
                }
                try {
                    const response = await fetch(`${this.apiBase}/remove-master-password/${id}`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-confirming-password': confirmingPassword
                        },
                        credentials: 'include',
                        body: JSON.stringify({ confirmingPassword })
                    });

                    if (!response.ok) {
                        let errorMsg = 'Fehler beim L√∂schen';
                        try {
                            const error = await response.json();
                            errorMsg = error.error || errorMsg;
                        } catch (_) {}
                        throw new Error(errorMsg);
                    }

                    return await response.json();
                } catch (error) {
                    throw error;
                }
            }

            async getMasterPasswords() {
                await this.ensureMode();
                if (this.localMode) {
                    const list = await LocalMode.getMasterPasswords();
                    return list.map(mp => ({ id: mp.id, name: mp.name, hint: mp.hint || '', createdAt: mp.createdAt }));
                }
                try {
                    const response = await fetch(`${this.apiBase}/master-passwords`);
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error);
                    }

                    return await response.json();
                } catch (error) {
                    throw error;
                }
            }

            async verifyMasterPassword(password, confirmingPassword) {
                await this.ensureMode();
                if (this.localMode) {
                    const list = await LocalMode.getMasterPasswords();
                    for (const mp of list) {
                        const hash = await pbkdf2HashHex(password, new Uint8Array(fromHex(mp.salt)), 64);
                        if (hash === mp.hashedPassword) {
                            // unwrap data key
                            const dataKeyHex = await unwrapDataKeyWithPassword(password, mp.salt, mp.wrappedDataKey, mp.wrapIv);
                            this.dataKeyHex = dataKeyHex;
                            this.isAuthenticated = true;
                            
                            // Cache the password for auto-login even in local mode
                            this.cachedMasterPassword = password;
                            this.setCachedPassword(password);
                            
                            return { masterPassword: { id: mp.id, name: mp.name } };
                        }
                    }
                    // If entry exists but not wrapped, require confirming password to link
                    if (confirmingPassword) {
                        // Try to find the entry by verifying confirmingPassword then wrap for provided password
                        const existing = list.find(m => true); // any entry
                        if (existing) {
                            const confirmHash = await pbkdf2HashHex(confirmingPassword, new Uint8Array(fromHex(existing.salt)), 64);
                            if (confirmHash === existing.hashedPassword) {
                                const dk = await unwrapDataKeyWithPassword(confirmingPassword, existing.salt, existing.wrappedDataKey, existing.wrapIv);
                                // find the target entry for 'password'
                                for (const mp of list) {
                                    const hash = await pbkdf2HashHex(password, new Uint8Array(fromHex(mp.salt)), 64);
                                    if (hash === mp.hashedPassword && (!mp.wrappedDataKey || !mp.wrapIv)) {
                                        const { wrappedDataKey, wrapIv } = await wrapDataKeyForPassword(password, mp.salt, dk);
                                        mp.wrappedDataKey = wrappedDataKey; mp.wrapIv = wrapIv;
                                        await LocalMode.saveMasterPasswords(list);
                                        this.dataKeyHex = dk;
                                        this.isAuthenticated = true;
                                        return { masterPassword: { id: mp.id, name: mp.name } };
                                    }
                                }
                            }
                        }
                    }
                    throw new Error('Invalid master password');
                }
                try {
                    const response = await fetch(`${this.apiBase}/verify-master-password`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        credentials: 'include',
                        body: JSON.stringify({ password, confirmingPassword })
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        const err = new Error(error.error || 'Login failed');
                        try { err.details = error; } catch (_) {}
                        
                        // Handle specific error codes
                        if (error.code === 'SESSION_CREATION_FAILED') {
                            err.message = 'Fehler beim Erstellen der Sitzung. Bitte versuchen Sie es erneut.';
                        } else if (error.code === 'LINK_REQUIRED') {
                            err.message = 'Verkn√ºpfung erforderlich. Bitte best√§tigen Sie mit einem bestehenden Master-Passwort.';
                        } else if (error.code === 'MIGRATION_CONFIRM_REQUIRED') {
                            err.message = 'Migration erforderlich. Bitte best√§tigen Sie mit einem bestehenden Master-Passwort.';
                        } else if (error.code === 'SESSION_TIMEOUT') {
                            err.message = 'Ihre Sitzung ist aufgrund von Inaktivit√§t abgelaufen. Bitte melden Sie sich erneut an.';
                        }
                        
                        throw err;
                    }

                    const result = await response.json();
                    this.masterPassword = password;
                    this.currentMasterPassword = result.masterPassword;
                    this.isAuthenticated = true;
                    
                    // Cache the password for transparent re-login (session-persistent)
                    this.cachedMasterPassword = password;
                    this.setCachedPassword(password);
                    
                    return result
                } catch (error) {
                    throw error;
                }
            }

            async loadPasswords(retryCount = 0) {
                try {
                    console.log(`loadPasswords called (attempt ${retryCount + 1})`);
                    await this.ensureMode();
                    
                    if (this.localMode) {
                        if (!this.isAuthenticated || !this.dataKeyHex) throw new Error('Nicht angemeldet. Bitte melden Sie sich zuerst an.');
                        const vault = await LocalMode.loadVault(this.dataKeyHex);
                        this.passwords = Array.isArray(vault.passwords) ? vault.passwords : [];
                        console.log('Local mode passwords loaded:', this.passwords.length);
                        this.renderPasswords();
                        return;
                    }
                    
                    if (!this.isAuthenticated) {
                        throw new Error('Nicht angemeldet. Bitte melden Sie sich zuerst an.');
                    }

                    // Add timeout and better error handling
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 60000); // 60 second timeout
                    
                    try {
                        const response = await fetch(`${this.apiBase}/all`, {
                            credentials: 'include',
                            signal: controller.signal
                        });
                        
                        clearTimeout(timeoutId);
                        
                        if (!response.ok) {
                            if (response.status === 401) {
                                this.isAuthenticated = false;
                                try { await fetch(`${this.apiBase}/logout`, { method: 'POST', credentials: 'include' }); } catch (_) {}
                                document.getElementById('mainContent').style.display = 'none';
                                document.getElementById('headerActions').style.display = 'none';
                                document.getElementById('loginScreen').style.display = 'block';
                                
                                this.showNotification('Sitzung abgelaufen. Bitte melden Sie sich erneut an.', 'error');
                                return;
                            }
                            
                            const error = await response.json();
                            throw new Error(error.error);
                        }

                        // Check if response is valid JSON
                        const text = await response.text();
                        if (!text || text.trim() === '') {
                            throw new Error('Leere Antwort vom Server erhalten');
                        }
                        
                        try {
                            this.passwords = JSON.parse(text);
                        } catch (parseError) {
                            console.error('JSON parse error:', parseError, 'Response text:', text.substring(0, 200));
                            throw new Error('Ung√ºltige JSON-Antwort vom Server');
                        }
                        
                        console.log('Server mode passwords loaded:', this.passwords.length);
                        console.log('Password folder distribution:', this.passwords.reduce((acc, p) => {
                            const folderId = p.folderId || 'null';
                            acc[folderId] = (acc[folderId] || 0) + 1;
                            return acc;
                        }, {}));
                        
                        this.renderPasswords();
                    } catch (fetchError) {
                        clearTimeout(timeoutId);
                        throw fetchError;
                    }
                } catch (error) {
                    console.error('Error loading passwords:', error);
                    
                    // Retry logic for network errors
                    if (retryCount < 2 && (error.name === 'AbortError' || error.message.includes('Failed to fetch'))) {
                        console.log(`Retrying loadPasswords in 2 seconds... (attempt ${retryCount + 1})`);
                        this.showNotification(`Lade Passw√∂rter erneut... (Versuch ${retryCount + 1}/3)`, 'info');
                        
                        setTimeout(() => {
                            this.loadPasswords(retryCount + 1);
                        }, 2000);
                        return;
                    }
                    
                    this.showNotification('Fehler beim Laden der Passw√∂rter: ' + error.message, 'error');
                    this.renderPasswords([]);
                }
            }

            async loadFolders() {
                try {
                    console.log('loadFolders called');
                    await this.ensureMode();
                    if (this.localMode) {
                        const vault = this.dataKeyHex ? await LocalMode.loadVault(this.dataKeyHex) : { folders: [] };
                        let folders = Array.isArray(vault.folders) ? vault.folders : [];
                        
                        // Validate and clean folder objects
                        const validFolders = folders.filter(f => {
                            return f && 
                                   typeof f === 'object' && 
                                   typeof f.id === 'string' && 
                                   f.id.trim().length > 0 &&
                                   typeof f.name === 'string' && 
                                   f.name.trim().length > 0;
                        });
                        
                        // Migrate existing folders without order index
                        let needsMigration = false;
                        validFolders.forEach((folder, index) => {
                            if (typeof folder.order !== 'number') {
                                folder.order = index;
                                folder.updatedAt = new Date().toISOString();
                                needsMigration = true;
                            }
                        });
                        
                        // Save migrated data if needed
                        if (needsMigration || validFolders.length !== folders.length) {
                            vault.folders = validFolders;
                            await LocalMode.saveVault(this.dataKeyHex, vault);
                        }
                        
                        // Sort folders by order index
                        validFolders.sort((a, b) => {
                            const orderA = typeof a.order === 'number' ? a.order : Number.MAX_SAFE_INTEGER;
                            const orderB = typeof b.order === 'number' ? b.order : Number.MAX_SAFE_INTEGER;
                            return orderA - orderB;
                        });
                        
                        this.folders = validFolders;
                        console.log('Local mode folders loaded:', this.folders);
                        this.hydrateFolderSelects();
                        return;
                    }
                    
                    const response = await fetch(`${this.apiBase}/folders`, { credentials: 'include' });
                    if (!response.ok) {
                        if (response.status === 401) {
                            this.isAuthenticated = false;
                            try { await fetch(`${this.apiBase}/logout`, { method: 'POST', credentials: 'include' }); } catch (_) {}
                            document.getElementById('mainContent').style.display = 'none';
                            document.getElementById('headerActions').style.display = 'none';
                            document.getElementById('loginScreen').style.display = 'block';
                            
                            // Show specific error message for authentication issues
                            this.showNotification('Sitzung abgelaufen. Bitte melden Sie sich erneut an.', 'error');
                            return; // Don't throw error, just return
                        }
                        throw new Error('Fehler beim Laden der Ordner');
                    }
                    const folders = await response.json();
                    
                    // Validate and clean folder objects from server
                    const validFolders = Array.isArray(folders) ? folders.filter(f => {
                        return f && 
                               typeof f === 'object' && 
                               typeof f.id === 'string' && 
                               f.id.trim().length > 0 &&
                               typeof f.name === 'string' && 
                               f.name.trim().length > 0;
                    }) : [];
                    
                    // Sort folders by order index
                    this.folders = validFolders.sort((a, b) => {
                        const orderA = typeof a.order === 'number' ? a.order : Number.MAX_SAFE_INTEGER;
                        const orderB = typeof b.order === 'number' ? b.order : Number.MAX_SAFE_INTEGER;
                        return orderA - orderB;
                    });
                    
                    console.log('Server mode folders loaded:', this.folders);
                    this.hydrateFolderSelects();
                    
                    // IMPORTANT: If passwords are already loaded, re-render them to show folder chips
                    if (this.passwords && this.passwords.length > 0) {
                        console.log('Re-rendering passwords after folders loaded to show folder chips');
                        this.renderPasswords();
                    }
                } catch (error) {
                    console.error('Error loading folders:', error);
                    this.folders = [];
                    this.hydrateFolderSelects();
                }
            }

            hydrateFolderSelects() {
                try {
                    console.log('hydrateFolderSelects called with folders:', this.folders);
                    
                    // Cache folder options for better performance
                    if (!this._folderOptionsCache || this._folderOptionsCache.foldersLength !== this.folders.length) {
                        this._buildFolderOptionsCache();
                    }
                    
                    // Toolbar filter
                    const filterSelect = document.getElementById('folderSelect');
                    if (filterSelect) {
                        filterSelect.innerHTML = this._folderOptionsCache.filterOptions;
                        filterSelect.value = this.selectedFolderId || 'all';
                        console.log('Updated filter select with value:', filterSelect.value);
                    }
                    
                    // Modal select for password
                    const pwdSelect = document.getElementById('passwordFolder');
                    if (pwdSelect) {
                        pwdSelect.innerHTML = this._folderOptionsCache.modalOptions;
                        console.log('Updated modal select');
                    }

                    // Drag & Drop folder bar
                    const dndBar = document.getElementById('folderDndBar');
                    if (dndBar) {
                        dndBar.innerHTML = this._folderOptionsCache.dndOptions;
                        this.setupFolderDropTargets();
                        this.setupFolderReorder();
                        console.log('Updated DnD bar');
                    }
                    
                    console.log('‚úÖ hydrateFolderSelects completed successfully');
                } catch (error) {
                    console.error('Error in hydrateFolderSelects:', error);
                }
            }

            // Build and cache folder options for better performance
            _buildFolderOptionsCache() {
                try {
                    console.log('Building folder options cache with folders:', this.folders);
                    
                    const seen = new Set();
                    const uniqueFolders = this.folders.filter(f => {
                        const key = String(f.name || '').trim().toLowerCase();
                        if (seen.has(key)) return false;
                        seen.add(key);
                        return true;
                    });

                    // Cache filter options
                    const filterOptions = '<option value="all">Alle Ordner</option><option value="null">Ohne Ordner</option>' +
                        uniqueFolders.map(f => `<option value="${f.id}">${this.escapeHtml(f.name)}</option>`).join('');

                    // Cache modal options
                    const modalOptions = '<option value="">Ohne Ordner</option>' +
                        uniqueFolders.map(f => `<option value="${f.id}">${this.escapeHtml(f.name)}</option>`).join('');

                    // Cache DnD options
                    const dndOptions = `<div class="folder-drop" data-folder-id="" role="button" tabindex="0"><span class="name">Ohne Ordner</span></div>` +
                        uniqueFolders.map(f => `<div class="folder-drop" data-folder-id="${f.id}" role="button" tabindex="0" draggable="true"><span class="name">${this.escapeHtml(f.name)}</span></div>`).join('');

                    this._folderOptionsCache = {
                        filterOptions,
                        modalOptions,
                        dndOptions,
                        foldersLength: this.folders.length
                    };
                    
                    console.log('‚úÖ Folder options cache built successfully:', {
                        filterOptions: filterOptions.length,
                        modalOptions: modalOptions.length,
                        dndOptions: dndOptions.length,
                        foldersLength: this.folders.length
                    });
                } catch (error) {
                    console.error('Error in _buildFolderOptionsCache:', error);
                }
            }

            // Clear caches when data changes
            _clearCaches() {
                try {
                    this._folderOptionsCache = null;
                    
                    // Clear folder chips cache completely
                    if (this._folderChipsCache) {
                        this._folderChipsCache.clear();
                        this._folderChipsCache = null;
                    }
                    
                    this._collator = null;
                    
                    // Force garbage collection hint for better memory management
                    if (window.gc) {
                        window.gc();
                    }
                } catch (error) {
                    console.error('Error clearing caches:', error);
                }
            }

            // Clear all caches including server-side caches
            _clearAllCaches() {
                try {
                    // Clear local caches
                    this._clearCaches();
                    
                    // Clear any other cached data
                    if (this._searchCache) {
                        this._searchCache.clear();
                    }
                    
                    // Force garbage collection hint (optional)
                    if (window.gc) {
                        window.gc();
                    }
                    
                    console.log('‚úÖ All caches cleared');
                } catch (error) {
                    console.error('Error clearing all caches:', error);
                }
            }

            // Background API call for folder deletion (fire and forget)
            async _deleteFolderInBackground(id) {
                try {
                    const res = await fetch(`${this.apiBase}/folders/${id}`, {
                        method: 'DELETE',
                        credentials: 'include'
                    });
                    
                    if (!res.ok) {
                        if (res.status === 401) {
                            // Session expired - show notification but don't revert UI
                            this.showNotification('Warnung: Sitzung abgelaufen. Bitte melden Sie sich erneut an.', 'warning');
                            return;
                        }
                        
                        // Other errors - log but don't revert UI
                        console.warn('Background folder deletion failed:', res.status, res.statusText);
                        return;
                    }
                    
                    const result = await res.json();
                    console.log('Background folder deletion successful:', result);
                    
                    // Always reload data to ensure consistency with server
                    console.log(`Reloading data after folder deletion (${result.movedPasswords || 0} passwords moved)`);
                    try {
                        // Clear all caches first
                        this._clearAllCaches();
                        // Reload both folders and passwords
                        await Promise.all([this.loadFolders(), this.loadPasswords()]);
                        this.renderPasswords();
                        console.log('‚úÖ Successfully reloaded data after folder deletion');
                    } catch (error) {
                        console.warn('Error reloading data after folder deletion:', error);
                    }
                } catch (error) {
                    // Network errors - log but don't revert UI
                    console.warn('Background folder deletion network error:', error);
                }
            }

            // Background API call for password moving (fire and forget)
            async _movePasswordInBackground(id, folderId, currentPassword) {
                try {
                    const response = await fetch(`${this.apiBase}/passwords/${id}/move`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ folderId })
                    });
                    
                    if (!response.ok) {
                        if (response.status === 401) {
                            // Session expired - show notification but don't revert UI
                            this.showNotification('Warnung: Sitzung abgelaufen. Bitte melden Sie sich erneut an.', 'warning');
                            return;
                        }
                        
                        // Other errors - log but don't revert UI
                        console.warn('Background password move failed:', response.status, response.statusText);
                        return;
                    }
                    
                    console.log('Background password move successful');
                    
                    // IMPORTANT: Reload passwords to ensure consistency with server
                    try {
                        await this.loadPasswords();
                        console.log('‚úÖ Passwords reloaded after move operation');
                    } catch (reloadError) {
                        console.warn('Error reloading passwords after move:', reloadError);
                    }
                } catch (error) {
                    // Network errors - log but don't revert UI
                    console.warn('Background password move network error:', error);
                }
            }

            // Background API call for folder creation (fire and forget)
            async _createFolderInBackground(name, newFolder) {
                try {
                    const res = await fetch(`${this.apiBase}/folders`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ name })
                    });
                    
                    if (!res.ok) {
                        if (res.status === 401) {
                            // Session expired - show notification but don't revert UI
                            this.showNotification('Warnung: Sitzung abgelaufen. Bitte melden Sie sich erneut an.', 'warning');
                            return;
                        }
                        
                        // Other errors - log but don't revert UI
                        console.warn('Background folder creation failed:', res.status, res.statusText);
                        return;
                    }
                    
                    // Update with server response to ensure consistency
                    const serverFolder = await res.json();
                    const index = this.folders.findIndex(f => f.id === newFolder.id);
                    if (index !== -1) {
                        this.folders[index] = serverFolder;
                    }
                    
                    console.log('Background folder creation successful');
                    
                    // IMPORTANT: Reload folders and passwords to ensure consistency
                    try {
                        await Promise.all([this.loadFolders(), this.loadPasswords()]);
                        console.log('‚úÖ Data reloaded after folder creation');
                    } catch (reloadError) {
                        console.warn('Error reloading data after folder creation:', reloadError);
                    }
                } catch (error) {
                    // Network errors - log but don't revert UI
                    console.warn('Background folder creation network error:', error);
                }
            }

            // Background API call for folder renaming (fire and forget)
            async _renameFolderInBackground(id, name, currentFolder) {
                try {
                    const res = await fetch(`${this.apiBase}/folders/${id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ name })
                    });
                    
                    if (!res.ok) {
                        if (res.status === 401) {
                            // Session expired - show notification but don't revert UI
                            this.showNotification('Warnung: Sitzung abgelaufen. Bitte melden Sie sich erneut an.', 'warning');
                            return;
                        }
                        
                        // Other errors - log but don't revert UI
                        console.warn('Background folder rename failed:', res.status, res.statusText);
                        return;
                    }
                    
                    // Update with server response to ensure consistency
                    const updatedFolder = await res.json();
                    const index = this.folders.findIndex(f => f.id === id);
                    if (index !== -1) {
                        this.folders[index] = updatedFolder;
                    }
                    
                    console.log('Background folder rename successful');
                    
                    // IMPORTANT: Reload data to ensure consistency
                    try {
                        await Promise.all([this.loadFolders(), this.loadPasswords()]);
                        
                        // Force UI update after data reload to ensure folder names are updated everywhere
                        this._clearCaches();
                        requestAnimationFrame(() => {
                            this.renderFoldersList();
                            this.renderPasswords();
                            this.hydrateFolderSelects();
                            
                                                // Force additional renders to ensure all changes are visible
                    setTimeout(() => {
                        this.renderPasswords();
                        setTimeout(() => {
                            this.renderPasswords();
                            
                            // Final render to ensure all folder chips are updated
                            setTimeout(() => {
                                this.renderPasswords();
                            }, 200);
                        }, 100);
                    }, 50);
                        });
                        
                        console.log('‚úÖ Data reloaded and UI updated after folder rename');
                    } catch (reloadError) {
                        console.warn('Error reloading data after folder rename:', reloadError);
                    }
                } catch (error) {
                    // Network errors - log but don't revert UI
                    console.warn('Background folder rename network error:', error);
                }
            }

            // Background API call for password deletion (fire and forget)
            async _deletePasswordInBackground(id) {
                try {
                    if (!this.isAuthenticated) {
                        console.warn('Cannot delete password - not authenticated');
                        return;
                    }

                    const response = await fetch(`${this.apiBase}/delete/${id}`, {
                        method: 'DELETE',
                        credentials: 'include'
                    });

                    if (!response.ok) {
                        if (response.status === 401) {
                            // Session expired - show notification but don't revert UI
                            this.showNotification('Warnung: Sitzung abgelaufen. Bitte melden Sie sich erneut an.', 'warning');
                            return;
                        }
                        
                        // Other errors - log but don't revert UI
                        const error = await response.json().catch(() => ({}));
                        console.warn('Background password deletion failed:', response.status, error.error || response.statusText);
                        return;
                    }
                    
                    console.log('Background password deletion successful');
                } catch (error) {
                    // Network errors - log but don't revert UI
                    console.warn('Background password deletion network error:', error);
                }
            }

            async addPassword(passwordData) {
                await this.ensureMode();
                if (this.localMode) {
                    if (!this.isAuthenticated || !this.dataKeyHex) throw new Error('Nicht angemeldet. Bitte melden Sie sich zuerst an.');
                    const vault = await LocalMode.loadVault(this.dataKeyHex);
                    const newPassword = { id: crypto.randomUUID(), ...passwordData, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() };
                    vault.passwords = Array.isArray(vault.passwords) ? vault.passwords : [];
                    vault.passwords.push(newPassword);
                    vault.encryptionScheme = ENCRYPTION_SCHEME;
                    await LocalMode.saveVault(this.dataKeyHex, vault);
                    this.passwords.push(newPassword);
                    this.renderPasswords();
                    this.showNotification('Passwort erfolgreich gespeichert!', 'success');
                    return;
                }
                try {
                    if (!this.isAuthenticated) {
                        throw new Error('Nicht angemeldet. Bitte melden Sie sich zuerst an.');
                    }

                    // Proactively re-check session before a write to handle expired sessions gracefully
                    const response = await this.fetchWithAuthRetry(`${this.apiBase}/add`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        credentials: 'include',
                        body: JSON.stringify(passwordData)
                    });

                    if (!response.ok) {
                        // If session expired or not authenticated, force login UI
                        if (response.status === 401) {
                            this.isAuthenticated = false;
                            const main = document.getElementById('mainContent');
                            const header = document.getElementById('headerActions');
                            const login = document.getElementById('loginScreen');
                            if (main) main.style.display = 'none';
                            if (header) header.style.display = 'none';
                            if (login) login.style.display = 'block';
                            
                            // Show specific error message for authentication issues
                            this.showNotification('Sitzung abgelaufen. Bitte melden Sie sich erneut an.', 'error');
                        }
                        const error = await response.json().catch(() => ({ error: 'Unbekannter Fehler' }));
                        throw new Error(error.error || 'Fehler');
                    }

                    const newPassword = await response.json();
                    this.passwords.push(newPassword);
                    this.renderPasswords();
                    this.showNotification('Passwort erfolgreich gespeichert!', 'success');
                } catch (error) {
                    this.showNotification('Fehler beim Speichern: ' + error.message, 'error');
                }
            }

            async updatePassword(id, passwordData) {
                await this.ensureMode();
                if (this.localMode) {
                    if (!this.isAuthenticated || !this.dataKeyHex) throw new Error('Nicht angemeldet. Bitte melden Sie sich zuerst an.');
                    const vault = await LocalMode.loadVault(this.dataKeyHex);
                    const idx = (vault.passwords || []).findIndex(p => p.id === id);
                    if (idx === -1) throw new Error('Password not found');
                    vault.passwords[idx] = { ...vault.passwords[idx], ...passwordData, updatedAt: new Date().toISOString() };
                    await LocalMode.saveVault(this.dataKeyHex, vault);
                    const localIdx = this.passwords.findIndex(p => p.id === id);
                    if (localIdx !== -1) this.passwords[localIdx] = vault.passwords[idx];
                    this.renderPasswords();
                    this.showNotification('Passwort erfolgreich aktualisiert!', 'success');
                    return;
                }
                try {
                    if (!this.isAuthenticated) {
                        throw new Error('Nicht angemeldet. Bitte melden Sie sich zuerst an.');
                    }

                    const response = await fetch(`${this.apiBase}/update/${id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        credentials: 'include',
                        body: JSON.stringify(passwordData)
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error);
                    }

                    const updatedPassword = await response.json();
                    const index = this.passwords.findIndex(p => p.id === id);
                    if (index !== -1) {
                        this.passwords[index] = updatedPassword;
                    }
                    this.renderPasswords();
                    this.showNotification('Passwort erfolgreich aktualisiert!', 'success');
                } catch (error) {
                    this.showNotification('Fehler beim Aktualisieren: ' + error.message, 'error');
                }
            }

            // New unified entry methods
            async addEntry(entryData) {
                await this.ensureMode();
                if (this.localMode) {
                    if (!this.isAuthenticated || !this.dataKeyHex) throw new Error('Nicht angemeldet. Bitte melden Sie sich zuerst an.');
                    const vault = await LocalMode.loadVault(this.dataKeyHex);
                    const newEntry = { 
                        id: crypto.randomUUID(), 
                        ...entryData, 
                        type: entryData.type || 'password', // Default to password for backward compatibility
                        createdAt: new Date().toISOString(), 
                        updatedAt: new Date().toISOString() 
                    };
                    vault.passwords = Array.isArray(vault.passwords) ? vault.passwords : [];
                    vault.passwords.push(newEntry);
                    vault.encryptionScheme = ENCRYPTION_SCHEME;
                    await LocalMode.saveVault(this.dataKeyHex, vault);
                    this.passwords.push(newEntry);
                    
                    const entryTypeName = this.getEntryTypeName(entryData.type);
                    this.renderPasswords();
                    this.showNotification(`${entryTypeName} erfolgreich hinzugef√ºgt!`, 'success');
                } else {
                    try {
                        if (!this.isAuthenticated) {
                            throw new Error('Nicht angemeldet. Bitte melden Sie sich zuerst an.');
                        }

                        const response = await fetch(`${this.apiBase}/entries`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include',
                            body: JSON.stringify(entryData)
                        });
                        
                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(error.error || 'Entry creation failed');
                        }
                        
                        const newEntry = await response.json();
                        this.passwords.push(newEntry);
                        this.renderPasswords();
                        
                        const entryTypeName = this.getEntryTypeName(entryData.type);
                        this.showNotification(`${entryTypeName} erfolgreich hinzugef√ºgt!`, 'success');
                    } catch (error) {
                        this.showNotification('Fehler beim Hinzuf√ºgen: ' + error.message, 'error');
                    }
                }
            }

            async updateEntry(id, entryData) {
                await this.ensureMode();
                if (this.localMode) {
                    if (!this.isAuthenticated || !this.dataKeyHex) throw new Error('Nicht angemeldet. Bitte melden Sie sich zuerst an.');
                    const vault = await LocalMode.loadVault(this.dataKeyHex);
                    const idx = (vault.passwords || []).findIndex(p => p.id === id);
                    if (idx === -1) throw new Error('Entry not found');
                    vault.passwords[idx] = { ...vault.passwords[idx], ...entryData, updatedAt: new Date().toISOString() };
                    await LocalMode.saveVault(this.dataKeyHex, vault);
                    const localIdx = this.passwords.findIndex(p => p.id === id);
                    if (localIdx !== -1) this.passwords[localIdx] = vault.passwords[idx];
                    
                    const entryTypeName = this.getEntryTypeName(entryData.type);
                    this.renderPasswords();
                    this.showNotification(`${entryTypeName} erfolgreich aktualisiert!`, 'success');
                } else {
                    try {
                        if (!this.isAuthenticated) {
                            throw new Error('Nicht angemeldet. Bitte melden Sie sich zuerst an.');
                        }

                        const response = await fetch(`${this.apiBase}/entries/${id}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include',
                            body: JSON.stringify(entryData)
                        });
                        
                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(error.error || 'Update failed');
                        }
                        
                        const updatedEntry = await response.json();
                        const index = this.passwords.findIndex(p => p.id === id);
                        if (index !== -1) {
                            this.passwords[index] = updatedEntry;
                        }
                        this.renderPasswords();
                        
                        const entryTypeName = this.getEntryTypeName(entryData.type);
                        this.showNotification(`${entryTypeName} erfolgreich aktualisiert!`, 'success');
                    } catch (error) {
                        this.showNotification('Fehler beim Aktualisieren: ' + error.message, 'error');
                    }
                }
            }

            getEntryTypeName(type) {
                switch(type) {
                    case 'password': return 'Passwort';
                    case 'website': return 'Webseite';
                    case 'link': return 'Link';
                    case 'note': return 'Notiz';
                    default: return 'Eintrag';
                }
            }

            async movePassword(id, folderId) {
                await this.ensureMode();
                if (this.localMode) {
                    const vault = await LocalMode.loadVault(this.dataKeyHex);
                    const idx = (vault.passwords || []).findIndex(p => p.id === id);
                    if (idx === -1) throw new Error('Password not found');
                    vault.passwords[idx] = { ...vault.passwords[idx], folderId: folderId || null, updatedAt: new Date().toISOString() };
                    await LocalMode.saveVault(this.dataKeyHex, vault);
                    const localIdx = this.passwords.findIndex(p => p.id === id);
                    if (localIdx !== -1) this.passwords[localIdx] = vault.passwords[idx];
                    this.renderPasswords();
                    this.showNotification('Verschoben', 'success');
                    return;
                }
                
                // Check if change is needed
                const currentPassword = this.passwords.find(p => p.id === id);
                if (currentPassword && currentPassword.folderId === folderId) {
                    return; // No change needed
                }
                
                try {
                    // Make API call first to ensure server consistency
                    const response = await fetch(`${this.apiBase}/passwords/${id}/move`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ folderId })
                    });
                    
                    if (!response.ok) {
                        if (response.status === 401) {
                            this.showNotification('Warnung: Sitzung abgelaufen. Bitte melden Sie sich erneut an.', 'warning');
                            return;
                        }
                        throw new Error(`Server error: ${response.status}`);
                    }
                    
                    // Server call successful, now reload passwords to ensure consistency
                    console.log('‚úÖ Password moved successfully to folder:', folderId);
                    
                    // Reload passwords from server to ensure consistency
                    try {
                        await this.loadPasswords();
                        console.log('‚úÖ Passwords reloaded after move operation');
                    } catch (reloadError) {
                        console.warn('Error reloading passwords after move:', reloadError);
                        
                        // Fallback: update UI optimistically
                        const index = this.passwords.findIndex(p => p.id === id);
                        if (index !== -1) {
                            this.passwords[index] = { ...this.passwords[index], folderId: folderId || null };
                            
                            // Clear caches and update UI smoothly
                            this._clearCaches();
                            requestAnimationFrame(() => {
                                this.renderPasswords();
                                this.hydrateFolderSelects();
                            });
                        }
                    }
                    
                    // Show success message
                    this.showNotification('Verschoben', 'success');
                } catch (error) {
                    console.error('Error moving password:', error);
                    this.showNotification('Fehler beim Verschieben: ' + error.message, 'error');
                }
            }

            async deletePassword(id) {
                await this.ensureMode();
                if (this.localMode) {
                    const vault = await LocalMode.loadVault(this.dataKeyHex);
                    vault.passwords = (vault.passwords || []).filter(p => p.id !== id);
                    await LocalMode.saveVault(this.dataKeyHex, vault);
                    this.passwords = this.passwords.filter(p => p.id !== id);
                    this.renderPasswords();
                    this.showNotification('Passwort erfolgreich gel√∂scht!', 'success');
                    return;
                }
                if (!confirm('Sind Sie sicher, dass Sie dieses Passwort l√∂schen m√∂chten?')) {
                    return;
                }

                // IMMEDIATE UI UPDATE - No waiting for server!
                try {
                    // Optimistic update: remove password immediately
                    this.passwords = this.passwords.filter(p => p.id !== id);
                    
                    // Clear caches and update UI smoothly
                    this._clearCaches();
                    requestAnimationFrame(() => this.renderPasswords());
                    
                    // Show success message immediately
                    this.showNotification('Passwort erfolgreich gel√∂scht!', 'success');
                    
                    // Fire and forget API call in background
                    this._deletePasswordInBackground(id);
                    
                } catch (uiError) {
                    console.error('Error updating UI after password deletion:', uiError);
                    this.showNotification('Passwort gel√∂scht, aber Fehler beim Aktualisieren der Anzeige', 'warning');
                }
            }

            filterByType(selectedType) {
                this.selectedEntryType = selectedType;
                this.currentPage = 1; // Reset to first page when filtering
                
                // Update active state for desktop buttons
                const typeFilterButtons = document.querySelectorAll('.type-filter-btn');
                typeFilterButtons.forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.type === selectedType) {
                        btn.classList.add('active');
                    }
                });
                
                // Update active state for mobile tiles
                const typeTiles = document.querySelectorAll('.type-tile');
                typeTiles.forEach(tile => {
                    tile.classList.remove('active');
                    if (tile.dataset.type === selectedType) {
                        tile.classList.add('active');
                    }
                });
                
                this.renderPasswords();
            }

            filterPasswords(searchTerm) {
                // Reset to first page when filtering
                this.currentPage = 1;
                
                const text = searchTerm.toLowerCase();
                
                // If there's a search term, search through ALL entries regardless of folder
                if (text.trim()) {
                    const filtered = this.passwords.filter(entry => {
                        // Search in title (all entry types have this)
                        if (entry.title.toLowerCase().includes(text)) return true;
                        
                        // Search in type-specific fields
                        const entryType = entry.type || 'password';
                        
                        switch(entryType) {
                            case 'password':
                                return (entry.username && entry.username.toLowerCase().includes(text)) ||
                                       (entry.url && entry.url.toLowerCase().includes(text));
                            
                            case 'note':
                                return (entry.content && entry.content.toLowerCase().includes(text));
                            
                            case 'website':
                            case 'link':
                                return (entry.url && entry.url.toLowerCase().includes(text));
                            
                            default:
                                return false;
                        }
                    });
                    this.renderPasswords(filtered);
                    return;
                }
                
                // If no search term, apply folder filter as normal
                const filtered = this.passwords.filter(entry => {
                    if (this.selectedFolderId === 'all') return true;
                    if (this.selectedFolderId === 'null') return (entry.folderId == null);
                    return entry.folderId === this.selectedFolderId;
                });
                this.renderPasswords(filtered);
            }

            renderPasswords(passwordsToRender = this.passwords) {
                try {
                    const container = document.getElementById('passwordsContainer');
                    if (!container) return;
                    
                    // Debug logging for folder filtering
                    console.log('renderPasswords called with:', {
                        totalPasswords: this.passwords.length,
                        selectedFolderId: this.selectedFolderId,
                        passwordsToRender: passwordsToRender.length
                    });
                    
                    // Apply current folder and type filters if full list passed
                    if (passwordsToRender === this.passwords) {
                        passwordsToRender = this.passwords.filter(p => {
                            // Folder filter
                            let folderMatch = true;
                            if (this.selectedFolderId !== 'all') {
                                if (this.selectedFolderId === 'null') {
                                    folderMatch = p.folderId == null;
                                } else {
                                    folderMatch = p.folderId === this.selectedFolderId;
                                }
                            }
                            
                            // Type filter
                            let typeMatch = true;
                            if (this.selectedEntryType && this.selectedEntryType !== 'all') {
                                const entryType = p.type || 'password';
                                typeMatch = entryType === this.selectedEntryType;
                            }
                            
                            return folderMatch && typeMatch;
                        });
                        
                        console.log('After filtering:', {
                            filteredCount: passwordsToRender.length,
                            selectedFolderId: this.selectedFolderId,
                            selectedEntryType: this.selectedEntryType
                        });
                    }

                    if (passwordsToRender.length === 0) {
                        container.innerHTML = `
                            <div class="empty-state">
                                <h3>${this.passwords.length === 0 ? 'Keine Eintr√§ge vorhanden' : 'Keine Eintr√§ge gefunden'}</h3>
                                <p>${this.passwords.length === 0 ? 'F√ºgen Sie Ihren ersten Eintrag hinzu, um zu beginnen.' : 'Versuchen Sie einen anderen Suchbegriff oder Filter.'}</p>
                            </div>
                        `;
                        return;
                    }

                    // Optimized sorting: only sort if needed and cache collator
                    let sorted = passwordsToRender;
                    if (passwordsToRender.length > 1) {
                        if (!this._collator) {
                            this._collator = new Intl.Collator('de', { sensitivity: 'base', numeric: true });
                        }
                        sorted = [...passwordsToRender].sort((a, b) => this._collator.compare(a.title, b.title));
                        if (this.sortOrder === 'za') {
                            sorted.reverse();
                        }
                    }

                    // Calculate pagination after sorting
                    const totalPages = Math.ceil(sorted.length / this.itemsPerPage);
                    const startIndex = (this.currentPage - 1) * this.itemsPerPage;
                    const endIndex = startIndex + this.itemsPerPage;
                    const currentPagePasswords = sorted.slice(startIndex, endIndex);

                    // Use DocumentFragment for better performance
                    const fragment = document.createDocumentFragment();
                    const passwordsList = document.createElement('div');
                    passwordsList.className = 'passwords-list';
                    passwordsList.innerHTML = currentPagePasswords.map(password => this.renderPasswordRow(password)).join('');
                    fragment.appendChild(passwordsList);
                    
                    if (totalPages > 1) {
                        const pagination = document.createElement('div');
                        pagination.innerHTML = this.renderPagination(totalPages, passwordsToRender.length);
                        fragment.appendChild(pagination);
                    }

                    // Clear and append in one operation
                    container.innerHTML = '';
                    container.appendChild(fragment);

                    // Add event listeners for expand/collapse
                    this.setupPasswordItemListeners();
                    this.makePasswordItemsDraggable();
                    
                    // Adjust textarea heights for notes
                    this.adjustNotesTextareaHeights();
                    
                    // Force folder chips to be rebuilt for next render
                    if (this._folderChipsCache) {
                        this._folderChipsCache.clear();
                        this._folderChipsCache = null;
                    }
                    
                    // Force folder options to be rebuilt for next render
                    if (this._folderOptionsCache) {
                        this._folderOptionsCache = null;
                    }
                    
                    console.log('‚úÖ renderPasswords completed successfully');
                } catch (error) {
                    console.error('Error in renderPasswords:', error);
                }
            }

            renderPasswordRow(password) {
                return this.renderEntryRow(password);
            }

            renderEntryRow(entry) {
                try {
                    const title = this.escapeHtml(entry.title);
                    const type = entry.type || 'password'; // Default to password for backward compatibility
                    const url = entry.url ? this.escapeHtml(entry.url) : '';
                    const notes = entry.notes ? this.escapeHtml(entry.notes) : '';
                    
                    // Pre-build folder chips for better performance
                    console.log(`Building folder chips for entry ${entry.id} (${entry.title}) with folderId: ${entry.folderId}`);
                    const folderChips = this._buildFolderChips(entry.id, entry.folderId);
                    
                    // Get type-specific icon and fields
                    const typeIcon = this.getEntryTypeIcon(type);
                    const typeFields = this.renderEntryTypeFields(entry, type);
                    
                    return `
                        <div class="password-item entry-${type}" data-password-id="${entry.id}">
                            <div class="password-header" role="button" tabindex="0" title="Details anzeigen">
                                <h3>${typeIcon} ${title}</h3>
                                <span class="chevron" aria-hidden="true"></span>
                            </div>
                            <div class="password-content">
                                <div class="password-details">
                                    ${typeFields}
                                    ${url ? `
                                        <div class="password-field">
                                            <label>URL:</label>
                                            <div class="value-with-actions">
                                                <div class="value-content">
                                                    <input type="text" value="${url}" readonly>
                                                </div>
                                                <div class="value-actions">
                                                    <button class="copy-btn" onclick="copyToClipboard('${url}')">Kopieren</button>
                                                    <button class="copy-btn" onclick="openEntryUrl('${url}')">üîó √ñffnen</button>
                                                </div>
                                            </div>
                                        </div>
                                    ` : ''}
                                    ${notes ? `
                                        <div class="password-field full">
                                            <label>Notizen:</label>
                                            <div class="value">
                                                <textarea readonly data-notes-textarea>${notes}</textarea>
                                            </div>
                                        </div>
                                    ` : ''}
                                    <div class="password-field">
                                        <label>Ordner:</label>
                                        <div class="folder-chips">
                                            ${folderChips}
                                        </div>
                                    </div>
                                </div>
                                <div class="row-footer">
                                    <button class="btn" onclick="editPassword('${entry.id}')">Bearbeiten</button>
                                    <button class="btn btn-danger" onclick="deletePassword('${entry.id}')">L√∂schen</button>
                                </div>
                            </div>
                        </div>
                    `;
                } catch (error) {
                    console.error('Error in renderEntryRow:', error);
                    return `<div class="password-item" data-password-id="${entry.id}">
                        <div class="password-header">
                            <h3>Fehler beim Rendern</h3>
                        </div>
                    </div>`;
                }
            }

            getEntryTypeIcon(type) {
                switch(type) {
                    case 'password': return 'üîê';
                    case 'website': return 'üåê';
                    case 'link': return 'üîó';
                    case 'note': return 'üìù';
                    default: return 'üìÑ';
                }
            }

            renderEntryTypeFields(entry, type) {
                switch(type) {
                    case 'password':
                        const username = this.escapeHtml(entry.username || '');
                        const passwordValue = this.escapeHtml(entry.password || '');
                        return `
                            <div class="password-field">
                                <label>Benutzername:</label>
                                <div class="value-with-actions">
                                    <div class="value-content">
                                        <input type="text" value="${username}" readonly>
                                    </div>
                                    <div class="value-actions">
                                        <button class="copy-btn" onclick="copyToClipboard('${username}')">Kopieren</button>
                                    </div>
                                </div>
                            </div>
                            <div class="password-field">
                                <label>Passwort:</label>
                                <div class="value-with-actions">
                                    <div class="value-content">
                                        <input type="password" value="${passwordValue}" readonly id="pwd-${entry.id}">
                                    </div>
                                    <div class="value-actions">
                                        <button class="copy-btn" onclick="copyToClipboard('${passwordValue}')">Kopieren</button>
                                        <button class="copy-btn" onclick="togglePasswordVisibility('${entry.id}')">üëÅÔ∏è</button>
                                    </div>
                                </div>
                            </div>
                        `;
                    case 'note':
                        const content = this.escapeHtml(entry.content || '');
                        return content ? `
                            <div class="password-field full">
                                <label>Inhalt:</label>
                                <div class="value">
                                    <textarea readonly data-notes-textarea>${content}</textarea>
                                </div>
                            </div>
                        ` : '';
                    case 'website':
                    case 'link':
                    default:
                        return ''; // URL field is handled in the main function
                }
            }

            escapeHtml(text) {
                try {
                    if (text == null || text === undefined) return '';
                    
                    // Use faster string replacement for common cases
                    const str = String(text);
                    if (str.length === 0) return '';
                    
                    // Fast path for strings without special characters
                    if (!/[<>&"']/.test(str)) return str;
                    
                    // Use optimized replacement for better performance
                    return str
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');
                } catch (error) {
                    console.error('Error in escapeHtml:', error);
                    return String(text || '');
                }
            }

            renderPagination(totalPages, totalItems) {
                try {
                    if (totalPages <= 1) return '';

                    const startItem = (this.currentPage - 1) * this.itemsPerPage + 1;
                    const endItem = Math.min(this.currentPage * this.itemsPerPage, totalItems);

                    let paginationHtml = '<div class="pagination">';
                    
                    // Previous button
                    paginationHtml += `<button onclick="passwordManager.goToPage(${this.currentPage - 1})" ${this.currentPage === 1 ? 'disabled' : ''}>‚Äπ</button>`;
                    
                    // Page numbers
                    const maxVisiblePages = 5;
                    let startPage = Math.max(1, this.currentPage - Math.floor(maxVisiblePages / 2));
                    let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
                    
                    if (endPage - startPage + 1 < maxVisiblePages) {
                        startPage = Math.max(1, endPage - maxVisiblePages + 1);
                    }

                    if (startPage > 1) {
                        paginationHtml += `<button onclick="passwordManager.goToPage(1)">1</button>`;
                        if (startPage > 2) {
                            paginationHtml += '<span>...</span>';
                        }
                    }

                    for (let i = startPage; i <= endPage; i++) {
                        paginationHtml += `<button onclick="passwordManager.goToPage(${i})" class="${i === this.currentPage ? 'active' : ''}">${i}</button>`;
                    }

                    if (endPage < totalPages) {
                        if (endPage < totalPages - 1) {
                            paginationHtml += '<span>...</span>';
                        }
                        paginationHtml += `<button onclick="passwordManager.goToPage(${totalPages})">${totalPages}</button>`;
                    }

                    // Next button
                    paginationHtml += `<button onclick="passwordManager.goToPage(${this.currentPage + 1})" ${this.currentPage === totalPages ? 'disabled' : ''}>‚Ä∫</button>`;
                    
                    paginationHtml += `<span class="pagination-info">${startItem}-${endItem} von ${totalItems}</span>`;
                    paginationHtml += '</div>';

                    return paginationHtml;
                } catch (error) {
                    console.error('Error in renderPagination:', error);
                    return '';
                }
            }

            goToPage(page) {
                try {
                    this.currentPage = page;
                    this.renderPasswords();
                } catch (error) {
                    console.error('Error in goToPage:', error);
                }
            }

            setupPasswordItemListeners() {
                try {
                    // In compact row layout there is no expandable header; guard against nulls
                    const passwordItems = document.querySelectorAll('.password-item');
                    passwordItems.forEach(item => {
                        const header = item.querySelector('.password-header');
                        if (!header) return;
                        header.addEventListener('click', () => {
                            item.classList.toggle('expanded');
                        });
                    });
                } catch (error) {
                    console.error('Error in setupPasswordItemListeners:', error);
                }
            }

            makePasswordItemsDraggable() {
                try {
                    const items = document.querySelectorAll('.password-item');
                    items.forEach(item => {
                        item.setAttribute('draggable', 'true');
                        item.addEventListener('dragstart', (e) => {
                            const id = item.getAttribute('data-password-id');
                            try {
                                e.dataTransfer.effectAllowed = 'move';
                                e.dataTransfer.setData('application/x-password-id', id);
                            } catch (_) {}
                            item.classList.add('dragging');
                        });
                        item.addEventListener('dragend', () => {
                            item.classList.remove('dragging');
                        });
                    });
                } catch (error) {
                    console.error('Error in makePasswordItemsDraggable:', error);
                }
            }

            setupFolderDropTargets() {
                try {
                    const targets = document.querySelectorAll('.folder-drop');
                    targets.forEach(t => {
                        t.addEventListener('dragover', (e) => {
                            const isPwd = Array.from(e.dataTransfer?.types || []).includes('application/x-password-id');
                            if (!isPwd) return; // ignore folder-reorder drags
                            e.preventDefault();
                            t.classList.add('active');
                        });
                        t.addEventListener('dragleave', () => {
                            t.classList.remove('active');
                        });
                        t.addEventListener('drop', (e) => {
                            const isPwd = Array.from(e.dataTransfer?.types || []).includes('application/x-password-id');
                            if (!isPwd) return; // ignore drops from folder chips
                            e.preventDefault();
                            t.classList.remove('active');
                            let id = '';
                            try { id = e.dataTransfer.getData('application/x-password-id'); } catch (_) {}
                            if (!id) return;
                            const folderId = t.getAttribute('data-folder-id') || null;
                            this.movePassword(id, folderId);
                        });
                        // Click to filter by this folder
                        t.addEventListener('click', () => {
                            const fid = t.getAttribute('data-folder-id');
                            const filterSelect = document.getElementById('folderSelect');
                            if (filterSelect) {
                                filterSelect.value = fid === '' ? 'null' : fid;
                                this.selectedFolderId = filterSelect.value;
                                this.currentPage = 1;
                                this.renderPasswords();
                            }
                        });
                    });
                } catch (error) {
                    console.error('Error in setupFolderDropTargets:', error);
                }
            }

            setupFolderReorder() {
                try {
                    const bar = document.getElementById('folderDndBar');
                    if (!bar) return;
                    const chips = Array.from(bar.querySelectorAll('.folder-drop'));
                    let draggingEl = null;

                    chips.forEach((chip) => {
                        if (!chip.getAttribute('draggable')) return; // skip non-draggable like "Ohne Ordner"
                        chip.addEventListener('dragstart', (e) => {
                            draggingEl = chip;
                            e.dataTransfer.effectAllowed = 'move';
                            try { e.dataTransfer.setData('text/plain', chip.dataset.folderId || ''); } catch (_) {}
                        });
                        chip.addEventListener('dragend', async () => {
                            const ids = Array.from(bar.querySelectorAll('.folder-drop'))
                                .map(el => el.dataset.folderId)
                                .filter(id => id);
                            if (Array.isArray(ids) && ids.length > 0) {
                                try { await this.reorderFolders(ids); } catch (_) {}
                            }
                            draggingEl = null;
                            Array.from(bar.querySelectorAll('.folder-drop')).forEach(el => el.classList.remove('drag-over'));
                        });
                    });

                    bar.addEventListener('dragover', (e) => {
                        if (!draggingEl) return;
                        e.preventDefault();
                        const target = e.target.closest('.folder-drop');
                        if (!target || target === draggingEl || !bar.contains(target)) return;
                        const rect = target.getBoundingClientRect();
                        const before = (e.clientX - rect.left) < rect.width / 2;
                        target.classList.add('drag-over');
                        if (before) {
                            bar.insertBefore(draggingEl, target);
                        } else {
                            bar.insertBefore(draggingEl, target.nextSibling);
                        }
                    });

                    bar.addEventListener('dragleave', (e) => {
                        const t = e.target.closest('.folder-drop');
                        if (t) t.classList.remove('drag-over');
                    });
                } catch (error) {
                    console.error('Error in setupFolderReorder:', error);
                }
            }

            async reorderFolders(orderIds) {
                try {
                    await this.ensureMode();
                    if (this.localMode) {
                        const vault = await LocalMode.loadVault(this.dataKeyHex);
                        const existing = Array.isArray(vault.folders) ? vault.folders : [];
                        const byId = new Map(existing.map(f => [f.id, f]));
                        const ordered = orderIds.map(id => byId.get(id)).filter(Boolean);
                        const rest = existing.filter(f => !orderIds.includes(f.id));
                        
                        // Update order indices for all folders
                        const allFolders = [...ordered, ...rest];
                        allFolders.forEach((folder, index) => {
                            folder.order = index;
                            folder.updatedAt = new Date().toISOString();
                        });
                        
                                            vault.folders = allFolders;
                    await LocalMode.saveVault(this.dataKeyHex, vault);
                    this.folders = vault.folders;
                    
                    // Clear caches and update UI smoothly
                    this._clearCaches();
                    requestAnimationFrame(() => this.hydrateFolderSelects());
                    return;
                    }
                    
                    const res = await this.fetchWithAuthRetry(`${this.apiBase}/folders/reorder`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ order: orderIds })
                    });
                    if (!res.ok) {
                        if (res.status === 401) {
                            this.isAuthenticated = false;
                            try { await fetch(`${this.apiBase}/logout`, { method: 'POST', credentials: 'include' }); } catch (_) {}
                            document.getElementById('mainContent').style.display = 'none';
                            document.getElementById('headerActions').style.display = 'none';
                            document.getElementById('loginScreen').style.display = 'block';
                            
                            // Show specific error message for authentication issues
                            this.showNotification('Sitzung abgelaufen. Bitte melden Sie sich erneut an.', 'error');
                            return; // Don't throw error, just return
                        }
                        throw new Error('Ordner-Reihenfolge konnte nicht gespeichert werden');
                    }
                    this.folders = await res.json();
                    
                    // Clear caches and update UI smoothly
                    this._clearCaches();
                    requestAnimationFrame(() => this.hydrateFolderSelects());
                } catch (error) {
                    console.error('Error in reorderFolders:', error);
                }
            }

            updatePasswordStrength(password) {
                const strengthBar = document.getElementById('strengthBar');
                let strength = 0;
                let className = 'strength-weak';

                if (password.length >= 8) strength += 25;
                if (password.match(/[a-z]/)) strength += 25;
                if (password.match(/[A-Z]/)) strength += 25;
                if (password.match(/[0-9]/)) strength += 25;
                if (password.match(/[^a-zA-Z0-9]/)) strength += 25;

                if (strength >= 100) {
                    className = 'strength-strong';
                } else if (strength >= 50) {
                    className = 'strength-medium';
                }

                strengthBar.style.width = Math.min(strength, 100) + '%';
                strengthBar.className = 'strength-bar ' + className;
            }

            generateSecurePassword() {
                const length = 16;
                const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?';
                let password = '';
                
                // Ensure at least one character from each category
                password += 'abcdefghijklmnopqrstuvwxyz'[Math.floor(Math.random() * 26)];
                password += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'[Math.floor(Math.random() * 26)];
                password += '0123456789'[Math.floor(Math.random() * 10)];
                password += '!@#$%^&*()_+-=[]{}|;:,.<>?'[Math.floor(Math.random() * 32)];
                
                // Fill the rest randomly
                for (let i = 4; i < length; i++) {
                    password += charset[Math.floor(Math.random() * charset.length)];
                }
                
                // Shuffle the password
                return password.split('').sort(() => Math.random() - 0.5).join('');
            }

            async exportData() {
                await this.ensureMode();
                if (this.localMode) {
                    const vault = await LocalMode.loadVault(this.dataKeyHex);
                    // Sort folders by order index for export
                    const sortedFolders = (vault.folders || []).sort((a, b) => {
                        const orderA = typeof a.order === 'number' ? a.order : Number.MAX_SAFE_INTEGER;
                        const orderB = typeof b.order === 'number' ? b.order : Number.MAX_SAFE_INTEGER;
                        return orderA - orderB;
                    });
                    
                    const exportData = { 
                        version: '1.4', 
                        exportDate: new Date().toISOString(), 
                        entries: vault.passwords || [], // Alle Eintragstypen (passwords, websites, links, notes)
                        passwords: vault.passwords || [], // F√ºr R√ºckw√§rtskompatibilit√§t
                        folders: sortedFolders
                    };

                    // Ask for export password (twice) using modal
                    const pass1 = await promptNewPasswordWithConfirm(8);
                    if (!pass1) { this.showNotification('Export abgebrochen.', 'error'); return; }

                    // Derive key and encrypt
                    const salt = crypto.getRandomValues(new Uint8Array(16));
                    const key = await deriveAesKeyFromString(pass1, salt);
                    const { encrypted, iv } = await encryptStringAesCbc(JSON.stringify(exportData), key);
                    const payload = { version: '1.4', scheme: 'export-v1-aes-cbc', salt: toHex(salt), iv, encrypted };

                    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `passwords_backup_encrypted_${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    this.showNotification('Verschl√ºsselter Export erstellt.', 'success');
                    return;
                }
                try {
                    const response = await fetch(`${this.apiBase}/export`, {
                        credentials: 'include'
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error);
                    }

                    const data = await response.json();

                    // Offer encryption for remote export as well (modal)
                    const pass1 = await promptNewPasswordWithConfirm(8);
                    if (!pass1) { this.showNotification('Export abgebrochen.', 'error'); return; }

                    const salt = crypto.getRandomValues(new Uint8Array(16));
                    const key = await deriveAesKeyFromString(pass1, salt);
                    const { encrypted, iv } = await encryptStringAesCbc(JSON.stringify(data), key);
                    const payload = { version: '1.4', scheme: 'export-v1-aes-cbc', salt: toHex(salt), iv, encrypted };

                    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `passwords_backup_encrypted_${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    this.showNotification('Verschl√ºsselter Export erstellt.', 'success');
                } catch (error) {
                    this.showNotification('Fehler beim Exportieren: ' + error.message, 'error');
                }
            }

            async importUnencryptedData(data) {
                // Neue Methode f√ºr unverschl√ºsselte Daten
                await this.ensureMode();
                if (this.localMode) {
                    try {
                        // Unterst√ºtze sowohl das neue 'entries' als auch das alte 'passwords' Format
                        const entries = data.entries || data.passwords;
                        if (!entries || !Array.isArray(entries)) {
                            throw new Error('Ung√ºltiges Dateiformat: entries/passwords-Array fehlt');
                        }
                        
                        const vault = await LocalMode.loadVault(this.dataKeyHex);
                        
                        // Import folders if they exist in the export data
                        if (data.folders && Array.isArray(data.folders)) {
                            const existingFolderNames = new Set(vault.folders.map(f => f.name.toLowerCase().trim()));
                            const newFolders = data.folders.filter(f => !existingFolderNames.has(f.name.toLowerCase().trim()));
                            
                            const importedFolders = newFolders.map((f, index) => ({
                                ...f,
                                id: f.id || crypto.randomUUID(),
                                order: typeof f.order === 'number' ? f.order : (vault.folders.length + index),
                                createdAt: f.createdAt || new Date().toISOString(),
                                updatedAt: new Date().toISOString()
                            }));
                            
                            vault.folders = [...vault.folders, ...importedFolders];
                            vault.folders.sort((a, b) => {
                                const orderA = typeof a.order === 'number' ? a.order : Number.MAX_SAFE_INTEGER;
                                const orderB = typeof b.order === 'number' ? b.order : Number.MAX_SAFE_INTEGER;
                                return orderA - orderB;
                            });
                        }
                        
                        // Import alle Eintr√§ge (passwords, websites, links, notes)
                        const importedEntries = entries.map(entry => ({
                            ...entry,
                            id: entry.id || crypto.randomUUID(),
                            type: entry.type || 'password', // Standard-Typ f√ºr R√ºckw√§rtskompatibilit√§t
                            createdAt: entry.createdAt || new Date().toISOString(),
                            updatedAt: new Date().toISOString()
                        }));
                        
                        vault.passwords = [...vault.passwords, ...importedEntries];
                        
                        await LocalMode.saveVault(this.dataKeyHex, vault);
                        await Promise.all([this.loadFolders(), this.loadPasswords()]);
                        
                        // Z√§hle verschiedene Eintragstypen f√ºr bessere Nachricht
                        const typeCounts = importedEntries.reduce((acc, entry) => {
                            acc[entry.type] = (acc[entry.type] || 0) + 1;
                            return acc;
                        }, {});
                        
                        const typeNames = {
                            'password': 'Passw√∂rter',
                            'website': 'Webseiten',
                            'link': 'Links',
                            'note': 'Notizen'
                        };
                        
                        const countMessages = Object.entries(typeCounts).map(([type, count]) => 
                            `${count} ${typeNames[type] || type}`
                        ).join(', ');
                        
                        this.showNotification(`${importedEntries.length} Eintr√§ge erfolgreich importiert: ${countMessages}`, 'success');
                    } catch (error) {
                        this.showNotification('Fehler beim Importieren: ' + error.message, 'error');
                    }
                    return;
                }
                
                // F√ºr Server-Modus
                try {
                    const response = await fetch(`${this.apiBase}/import`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        credentials: 'include',
                        body: JSON.stringify({ 
                            entries: entries,
                            passwords: entries, // F√ºr R√ºckw√§rtskompatibilit√§t 
                            folders: data.folders || []
                        })
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error);
                    }

                    // Wait a moment for the server to process the import
                    this.showNotification(`Import erfolgreich! Lade ${entries.length} Eintr√§ge...`, 'info');
                    
                    // Add delay before reloading to ensure server has processed the import
                    setTimeout(async () => {
                        try {
                            await Promise.all([this.loadFolders(), this.loadPasswords()]);
                            this.showNotification(`${entries.length} Eintr√§ge erfolgreich importiert und geladen!`, 'success');
                        } catch (reloadError) {
                            console.error('Error reloading after import:', reloadError);
                            this.showNotification('Import erfolgreich, aber Fehler beim Laden der Passw√∂rter. Bitte laden Sie die Seite neu.', 'warning');
                        }
                    }, 2000);
                } catch (error) {
                    this.showNotification('Fehler beim Importieren: ' + error.message, 'error');
                }
            }

            async importData(file) {
                await this.ensureMode();
                if (this.localMode) {
                    try {
                        const text = await file.text();
                        let data = JSON.parse(text);
                        // Encrypted export payload support
                        if (data && data.encrypted && data.iv && data.salt) {
                            const pass = await promptPassword('Passwort erforderlich', 'Passwort f√ºr den Import eingeben:');
                            if (!pass) throw new Error('Import abgebrochen');
                            const key = await deriveAesKeyFromString(pass, new Uint8Array(fromHex(data.salt)));
                            const json = await decryptStringAesCbc(data.encrypted, data.iv, key);
                            data = JSON.parse(json || '{}');
                        }
                        // Unterst√ºtze sowohl das neue 'entries' als auch das alte 'passwords' Format
                        const entries = data.entries || data.passwords;
                        if (!entries || !Array.isArray(entries)) throw new Error('Ung√ºltiges Dateiformat');
                        
                        const vault = await LocalMode.loadVault(this.dataKeyHex);
                        
                        // Import folders if they exist in the export data (backward compatible)
                        if (data.folders && Array.isArray(data.folders)) {
                            // Merge folders, avoiding duplicates by name
                            const existingFolderNames = new Set(vault.folders.map(f => f.name.toLowerCase().trim()));
                            const newFolders = data.folders.filter(f => !existingFolderNames.has(f.name.toLowerCase().trim()));
                            
                            // Preserve order from export data
                            const importedFolders = newFolders.map((f, index) => ({
                                ...f,
                                id: f.id || crypto.randomUUID(),
                                order: typeof f.order === 'number' ? f.order : (vault.folders.length + index),
                                createdAt: f.createdAt || new Date().toISOString(),
                                updatedAt: new Date().toISOString()
                            }));
                            
                            vault.folders = [...vault.folders, ...importedFolders];
                            
                            // Sort all folders by order index
                            vault.folders.sort((a, b) => {
                                const orderA = typeof a.order === 'number' ? a.order : Number.MAX_SAFE_INTEGER;
                                const orderB = typeof b.order === 'number' ? b.order : Number.MAX_SAFE_INTEGER;
                                return orderA - orderB;
                            });
                        }
                        // For older exports without folders, we'll keep existing folders
                        
                        // Import alle Eintr√§ge (passwords, websites, links, notes)
                        vault.passwords = entries.map(entry => ({
                            ...entry,
                            id: entry.id || crypto.randomUUID(),
                            type: entry.type || 'password', // Standard-Typ f√ºr R√ºckw√§rtskompatibilit√§t
                            createdAt: entry.createdAt || new Date().toISOString(),
                            updatedAt: new Date().toISOString()
                        }));
                        
                        await LocalMode.saveVault(this.dataKeyHex, vault);
                        
                        // Wait a moment before reloading
                        this.showNotification('Import erfolgreich! Lade Daten...', 'info');
                        
                        setTimeout(async () => {
                            try {
                                await Promise.all([this.loadFolders(), this.loadPasswords()]);
                                this.showNotification('Daten erfolgreich importiert und geladen!', 'success');
                            } catch (reloadError) {
                                console.error('Error reloading after local import:', reloadError);
                                this.showNotification('Import erfolgreich, aber Fehler beim Laden der Daten. Bitte laden Sie die Seite neu.', 'warning');
                            }
                        }, 1000);
                    } catch (error) {
                        this.showNotification('Fehler beim Importieren: ' + error.message, 'error');
                    }
                    return;
                }
                try {
                    const text = await file.text();
                    let data = JSON.parse(text);
                    if (data && data.encrypted && data.iv && data.salt) {
                        const pass = await promptPassword('Passwort erforderlich', 'Passwort f√ºr den Import eingeben:');
                        if (!pass) throw new Error('Import abgebrochen');
                        const key = await deriveAesKeyFromString(pass, new Uint8Array(fromHex(data.salt)));
                        const json = await decryptStringAesCbc(data.encrypted, data.iv, key);
                        data = JSON.parse(json || '{}');
                    }
                    
                    // Unterst√ºtze sowohl das neue 'entries' als auch das alte 'passwords' Format
                    const entries = data.entries || data.passwords;
                    if (!entries || !Array.isArray(entries)) {
                        throw new Error('Ung√ºltiges Dateiformat');
                    }

                    const response = await fetch(`${this.apiBase}/import`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        credentials: 'include',
                        body: JSON.stringify({ 
                            entries: entries,
                            passwords: entries, // F√ºr R√ºckw√§rtskompatibilit√§t
                            folders: data.folders || []
                        })
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error);
                    }

                    // Reload both folders and passwords after import
                    await Promise.all([this.loadFolders(), this.loadPasswords()]);
                                            // Z√§hle verschiedene Eintragstypen f√ºr bessere Nachricht
                        const typeCounts = entries.reduce((acc, entry) => {
                            const type = entry.type || 'password';
                            acc[type] = (acc[type] || 0) + 1;
                            return acc;
                        }, {});
                        
                        const typeNames = {
                            'password': 'Passw√∂rter',
                            'website': 'Webseiten',
                            'link': 'Links',
                            'note': 'Notizen'
                        };
                        
                        const countMessages = Object.entries(typeCounts).map(([type, count]) => 
                            `${count} ${typeNames[type] || type}`
                        ).join(', ');
                        
                        this.showNotification(`${entries.length} Eintr√§ge erfolgreich importiert: ${countMessages}`, 'success');
                } catch (error) {
                    this.showNotification('Fehler beim Importieren: ' + error.message, 'error');
                }
            }

            showNotification(message, type = 'success') {
                showToast(message, type);
            }

            // ------- Folder methods -------
            async createFolder(name) {
                await this.ensureMode();
                if (this.localMode) {
                    const vault = await LocalMode.loadVault(this.dataKeyHex);
                    vault.folders = Array.isArray(vault.folders) ? vault.folders : [];
                    const normalized = String(name).trim().toLowerCase();
                    const existing = vault.folders.find(f => String(f.name || '').trim().toLowerCase() === normalized);
                    if (existing) { 
                        this.folders = vault.folders; 
                        this.hydrateFolderSelects();
                        return; 
                    }
                    const newFolder = { 
                        id: crypto.randomUUID(), 
                        name: String(name).trim(), 
                        order: vault.folders.length, // Set order to end of list
                        createdAt: new Date().toISOString(), 
                        updatedAt: new Date().toISOString() 
                    };
                    vault.folders.push(newFolder);
                    await LocalMode.saveVault(this.dataKeyHex, vault);
                    this.folders = vault.folders;
                    
                    // Clear caches and update UI immediately
                    this._clearCaches();
                    requestAnimationFrame(() => {
                        this.hydrateFolderSelects();
                        this.renderFoldersList();
                        this.renderPasswords();
                    });
                    
                    this.showNotification('Ordner erstellt', 'success');
                    return;
                }
                
                // Optimistic update for smoother UX
                const newFolder = { 
                    id: crypto.randomUUID(), 
                    name: String(name).trim(), 
                    order: this.folders.length, // Set order to end of list
                    createdAt: new Date().toISOString(), 
                    updatedAt: new Date().toISOString() 
                };
                this.folders.push(newFolder);
                
                // Clear caches and update UI smoothly
                this._clearCaches();
                requestAnimationFrame(() => {
                    this.hydrateFolderSelects();
                    this.renderFoldersList();
                    this.renderPasswords();
                });
                
                // Show success message immediately
                this.showNotification('Ordner erstellt', 'success');
                
                // Fire and forget API call in background
                this._createFolderInBackground(name, newFolder);
            }

            async renameFolder(id) {
                await this.ensureMode();
                if (this.localMode) {
                    const input = document.querySelector(`input[data-folder-id='${id}']`);
                    const name = (input?.value || '').trim();
                    if (!name) return;
                    const vault = await LocalMode.loadVault(this.dataKeyHex);
                    const idx = (vault.folders || []).findIndex(f => f.id === id);
                    if (idx === -1) throw new Error('Folder not found');
                    vault.folders[idx].name = name;
                    vault.folders[idx].updatedAt = new Date().toISOString();
                    await LocalMode.saveVault(this.dataKeyHex, vault);
                    this.folders = vault.folders;
                    
                    // Clear caches and update UI completely
                    this._clearCaches();
                    
                    // Force immediate update of all password displays to show new folder names
                    requestAnimationFrame(() => {
                        this.renderFoldersList();
                        this.renderPasswords();
                        this.hydrateFolderSelects();
                        
                                            // Force a second render to ensure all folder chips are updated
                    setTimeout(() => {
                        this.renderPasswords();
                        
                                                    // Force a third render to ensure all changes are visible
                            setTimeout(() => {
                                this.renderPasswords();
                                
                                // Final render to ensure all folder chips are updated
                                setTimeout(() => {
                                    this.renderPasswords();
                                }, 200);
                            }, 100);
                    }, 50);
                    });
                    
                    this.showNotification('Ordner umbenannt', 'success');
                    return;
                }
                const input = document.querySelector(`input[data-folder-id='${id}']`);
                const name = (input?.value || '').trim();
                if (!name) return;
                
                // Optimistic update for smoother UX
                const currentFolder = this.folders.find(f => f.id === id);
                if (currentFolder && currentFolder.name === name) {
                    return; // No change needed
                }
                
                // Update UI immediately for smooth experience
                const index = this.folders.findIndex(f => f.id === id);
                if (index !== -1) {
                    this.folders[index] = { ...this.folders[index], name: name };
                    
                    // Clear caches and update UI smoothly
                    this._clearCaches();
                    
                    // Force immediate update of all password displays to show new folder names
                    requestAnimationFrame(() => {
                        this.renderFoldersList();
                        this.renderPasswords();
                        this.hydrateFolderSelects();
                        
                        // Force a second render to ensure all folder chips are updated
                        setTimeout(() => {
                            this.renderPasswords();
                            
                            // Force a third render to ensure all changes are visible
                            setTimeout(() => {
                                this.renderPasswords();
                                
                                // Final render to ensure all folder chips are updated
                                setTimeout(() => {
                                    this.renderPasswords();
                                }, 200);
                            }, 100);
                        }, 50);
                    });
                    
                    // Show success message immediately
                    this.showNotification('Ordner umbenannt', 'success');
                }
                
                // Fire and forget API call in background
                this._renameFolderInBackground(id, name, currentFolder);
            }

            async deleteFolder(id) {
                await this.ensureMode();
                if (this.localMode) {
                    if (!confirm('Ordner wirklich l√∂schen? Passw√∂rter werden in "Ohne Ordner" verschoben.')) return;
                    const vault = await LocalMode.loadVault(this.dataKeyHex);
                    
                    // Count passwords to be moved for notification
                    const passwordsToMove = (vault.passwords || []).filter(p => p.folderId === id);
                    
                    vault.folders = (vault.folders || []).filter(f => f.id !== id);
                    // Reassign passwords
                    vault.passwords = (vault.passwords || []).map(p => p.folderId === id ? { ...p, folderId: null, updatedAt: new Date().toISOString() } : p);
                    await LocalMode.saveVault(this.dataKeyHex, vault);
                    
                    // Update local state
                    this.folders = vault.folders;
                    this.passwords = vault.passwords;
                    
                    // Clear caches and reset folder selection
                    this._clearCaches();
                    this.selectedFolderId = 'all';
                    
                    // Update UI completely
                    requestAnimationFrame(() => {
                        this.renderFoldersList();
                        this.renderPasswords();
                        this.hydrateFolderSelects();
                    });
                    
                    // Debug: Log password states
                    console.log('After folder deletion:');
                    console.log('Passwords with null folderId:', this.passwords.filter(p => p.folderId === null || p.folderId === undefined));
                    console.log('All passwords:', this.passwords.map(p => ({id: p.id, title: p.title, folderId: p.folderId})));
                    
                    this.showNotification(`Ordner gel√∂scht (${passwordsToMove.length} Passw√∂rter in "Ohne Ordner" verschoben)`, 'success');
                    return;
                }
                if (!confirm('Ordner wirklich l√∂schen? Passw√∂rter werden in "Ohne Ordner" verschoben.')) return;
                
                // IMMEDIATE UI UPDATE - No waiting for server!
                try {
                    // Optimistic update: remove folder and move passwords in one operation
                    const passwordsToUpdate = this.passwords.filter(p => p.folderId === id);
                    this.folders = this.folders.filter(f => f.id !== id);
                    this.passwords = this.passwords.map(p => 
                        p.folderId === id ? { ...p, folderId: null, updatedAt: new Date().toISOString() } : p
                    );
                    
                    // Debug: Log password states
                    console.log('Server mode - After folder deletion:');
                    console.log('Passwords with null folderId:', this.passwords.filter(p => p.folderId === null || p.folderId === undefined));
                    console.log('All passwords:', this.passwords.map(p => ({id: p.id, title: p.title, folderId: p.folderId})));
                    
                    // Update UI IMMEDIATELY for instant feedback
                    this.updateUIAfterFolderDeletion();
                    
                    // Show success message immediately with correct count
                    const movedCount = passwordsToUpdate.length;
                    this.showNotification(`Ordner gel√∂scht (${movedCount} Passwort${movedCount !== 1 ? 'er' : ''} in "Ohne Ordner" verschoben)`, 'success');
                    
                    // Fire and forget API call in background
                    this._deleteFolderInBackground(id);
                    
                } catch (uiError) {
                    console.error('Error updating UI after folder deletion:', uiError);
                    this.showNotification('Ordner gel√∂scht, aber Fehler beim Aktualisieren der Anzeige', 'warning');
                }
            }

            // Optimized batch UI update function for folder deletion
            updateUIAfterFolderDeletion() {
                try {
                    // Clear caches for fresh data
                    this._clearCaches();
                    
                    // Reset folder selection to "all" to ensure deleted folders don't cause issues
                    this.selectedFolderId = 'all';
                    
                    // Use requestAnimationFrame for smooth UI updates
                    requestAnimationFrame(() => {
                        this.renderFoldersList();
                        this.renderPasswords();
                        this.hydrateFolderSelects();
                        
                        // Force a re-render to ensure all changes are visible
                        setTimeout(() => {
                            this.renderPasswords();
                        }, 100);
                    });
                } catch (error) {
                    console.error('Error in updateUIAfterFolderDeletion:', error);
                }
            }

            // Optimized folder chips builder for better performance
            _buildFolderChips(passwordId, passwordFolderId) {
                try {
                    // Cache folder chips for better performance
                    if (!this._folderChipsCache) {
                        this._folderChipsCache = new Map();
                    }
                    
                    // Create a more robust cache key that includes folder names and IDs
                    const folderSignature = this.folders.map(f => `${f.id}:${f.name}`).join('|');
                    const cacheKey = `${passwordId}_${passwordFolderId}_${folderSignature}`;
                    
                    if (this._folderChipsCache.has(cacheKey)) {
                        return this._folderChipsCache.get(cacheKey);
                    }
                    
                    console.log(`_buildFolderChips: passwordId=${passwordId}, passwordFolderId=${passwordFolderId}, folders:`, this.folders);
                    
                    const chips = [
                        `<span class="folder-chip ${!passwordFolderId ? 'selected' : ''}" onclick="passwordManager.movePassword('${passwordId}', null)">Ohne Ordner</span>`
                    ];
                    
                    for (const folder of this.folders) {
                        const isSelected = passwordFolderId === folder.id;
                        console.log(`Folder ${folder.id} (${folder.name}): isSelected=${isSelected} (${passwordFolderId} === ${folder.id})`);
                        chips.push(`<span class="folder-chip ${isSelected ? 'selected' : ''}" onclick="passwordManager.movePassword('${passwordId}', '${folder.id}')">${this.escapeHtml(folder.name)}</span>`);
                    }
                    
                    const result = chips.join('');
                    this._folderChipsCache.set(cacheKey, result);
                    
                    // Debug: Log the result
                    console.log(`Generated folder chips for password ${passwordId}:`, result);
                    
                    return result;
                } catch (error) {
                    console.error('Error in _buildFolderChips:', error);
                    return '<span class="folder-chip">Fehler</span>';
                }
            }

            adjustNotesTextareaHeights() {
                try {
                    const textareas = document.querySelectorAll('[data-notes-textarea]');
                    textareas.forEach(textarea => {
                        // Reset height to auto to get the correct scrollHeight
                        textarea.style.height = 'auto';
                        // Set height to scrollHeight to fit content
                        const scrollHeight = textarea.scrollHeight;
                        textarea.style.height = Math.max(60, Math.min(scrollHeight, 200)) + 'px';
                    });
                } catch (error) {
                    console.error('Error adjusting textarea heights:', error);
                }
            }

            renderFoldersList() {
                try {
                    const container = document.getElementById('foldersList');
                    if (!container) return;
                    if (this.folders.length === 0) {
                        container.innerHTML = '<p style="color:#6b7280;">Noch keine Ordner angelegt.</p>';
                        return;
                    }
                    
                    // Use DocumentFragment for better performance
                    const fragment = document.createDocumentFragment();
                    
                    for (const folder of this.folders) {
                        const folderDiv = document.createElement('div');
                        folderDiv.className = 'folder-item';
                        folderDiv.style.cssText = 'padding:16px 0; border-bottom:1px solid #f3f4f6;';
                        
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.value = folder.name;
                        input.setAttribute('data-folder-id', folder.id);
                        input.style.cssText = 'width:100%; padding:10px; border:1px solid #d1d5db; border-radius:8px; margin-bottom:12px; box-sizing:border-box;';
                        
                        const buttonGroup = document.createElement('div');
                        buttonGroup.className = 'folder-button-group';
                        buttonGroup.style.cssText = 'display:flex; gap:8px;';
                        
                        const renameBtn = document.createElement('button');
                        renameBtn.className = 'btn btn-secondary';
                        renameBtn.style.cssText = 'flex:1; font-size:14px;';
                        renameBtn.textContent = 'Umbenennen';
                        renameBtn.onclick = () => this.renameFolder(folder.id);
                        
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'btn btn-danger';
                        deleteBtn.style.cssText = 'flex:1; font-size:14px;';
                        deleteBtn.textContent = 'L√∂schen';
                        deleteBtn.onclick = () => this.deleteFolder(folder.id);
                        
                        buttonGroup.appendChild(renameBtn);
                        buttonGroup.appendChild(deleteBtn);
                        
                        folderDiv.appendChild(input);
                        folderDiv.appendChild(buttonGroup);
                        fragment.appendChild(folderDiv);
                    }
                    
                    container.innerHTML = '';
                    container.appendChild(fragment);
                } catch (error) {
                    console.error('Error in renderFoldersList:', error);
                }
            }

            async logout() {
                await this.ensureMode();
                if (this.localMode) {
                    this.isAuthenticated = false;
                    this.masterPassword = '';
                    this.currentMasterPassword = null;
                    this.dataKeyHex = null;
                    return;
                }
                try {
                    const response = await fetch(`${this.apiBase}/logout`, {
                        method: 'POST',
                        credentials: 'include'
                    });
                    
                    if (response.ok) {
                        this.isAuthenticated = false;
                        this.masterPassword = '';
                        this.currentMasterPassword = null;
                        this.passwords = [];
                    }
                } catch (error) {
                    console.error('Error during logout:', error);
                }
            }
        }

        // App version - update this when changing package.json version
        const APP_VERSION = '1.9.0';
        
        // Global variables
        let passwordManager;
        let currentEditingId = null;

        // Utility functions
        async function login() {
            const masterPassword = document.getElementById('masterPassword').value;

            if (!masterPassword) {
                alert('Bitte geben Sie ein Master-Passwort ein.');
                return;
            }

            // Check for session recovery before proceeding
            if (passwordManager && passwordManager.sessionRecoverable) {
                // Show recovery notice
                document.getElementById('sessionRecoveryNotice').style.display = 'block';
            }

            try {
                // Show loading state
                document.getElementById('loginScreen').style.display = 'none';
                document.getElementById('initialLoading').style.display = 'flex';
                document.querySelector('#initialLoading .loading-content p').textContent = 'Anmelden...';
                
                passwordManager = new PasswordManager();
                
                // Check if master password is already set
                const isSet = await passwordManager.checkMasterPasswordStatus();
                console.log('Master password set:', isSet);
                
                // Add a small delay to ensure the backend is ready
                await new Promise(resolve => setTimeout(resolve, 100));
                
                if (isSet) {
                    // Master password exists, verify it
                    if (masterPassword.length < 8) {
                        alert('Das Master-Passwort muss mindestens 8 Zeichen lang sein.');
                        document.getElementById('initialLoading').style.display = 'none';
                        document.getElementById('loginScreen').style.display = 'block';
                        return;
                    }
                    
                    console.log('Verifying master password...');
                        try {
                        await passwordManager.verifyMasterPassword(masterPassword);
                        // mini delay -> file-store writes are fs-based
                        await new Promise(r => setTimeout(r, 100)); // Small delay for session creation
                        passwordManager.cachedMasterPassword = masterPassword;
                        } catch (e) {
                            const needsLink = (e.details && e.details.code === 'LINK_REQUIRED') || /Linking required/i.test(e.message || '');
                            if (needsLink) {
                                const confirming = await promptPassword('Verkn√ºpfung erforderlich', 'Dieses Master-Passwort ist neu und muss mit einem bestehenden Master-Passwort verkn√ºpft werden. Bitte bestehendes Master-Passwort eingeben:');
                                if (!confirming) throw e;
                                await passwordManager.verifyMasterPassword(masterPassword, confirming);
                            } else {
                                throw e;
                            }
                        }
                    console.log('Master password verified successfully');
                } else {
                    // First time setup, add master password
                    if (masterPassword.length < 8) {
                        alert('Das Master-Passwort muss mindestens 8 Zeichen lang sein.');
                        document.getElementById('initialLoading').style.display = 'none';
                        document.getElementById('loginScreen').style.display = 'block';
                        return;
                    }
                    
                    console.log('Adding master password...');
                    await passwordManager.addMasterPassword(masterPassword, 'Hauptzugang');
                    await new Promise(r => setTimeout(r, 600000000000)); // Increased delay for session creation
                    passwordManager.cachedMasterPassword = masterPassword;
                    console.log('Master password added successfully');
                }
                
                console.log('Loading passwords...');
                document.querySelector('#initialLoading .loading-content p').textContent = 'Lade Passw√∂rter...';
                await Promise.all([passwordManager.loadFolders(), passwordManager.loadPasswords()]);
                console.log('Passwords loaded successfully');
                
                // Initialize activity tracking for session extension
                passwordManager.initActivityTracking();
                
                // Start session timer
                passwordManager.startSessionTimer();
                
                document.getElementById('initialLoading').style.display = 'none';
                document.getElementById('mainContent').style.display = 'block';
                document.getElementById('topActions').style.display = 'flex';
                
                // Clear form
                document.getElementById('masterPassword').value = '';
                
            } catch (error) {
                console.error('Login error:', error);
                
                // Show specific error message
                let errorMessage = 'Fehler beim Anmelden: ' + error.message;
                if (error.message.includes('Invalid master password')) {
                    errorMessage = 'Ung√ºltiges Master-Passwort.';
                } else if (error.message.includes('LINK_REQUIRED')) {
                    errorMessage = 'Verkn√ºpfung erforderlich. Bitte best√§tigen Sie mit einem bestehenden Master-Passwort.';
                } else if (error.message.includes('MIGRATION_CONFIRM_REQUIRED')) {
                    errorMessage = 'Migration erforderlich. Bitte best√§tigen Sie mit einem bestehenden Master-Passwort.';
                } else if (error.message.includes('SESSION_CREATION_FAILED')) {
                    errorMessage = 'Fehler beim Erstellen der Sitzung. Bitte versuchen Sie es erneut.';
                } else if (error.message.includes('Nicht angemeldet')) {
                    errorMessage = 'Sitzung abgelaufen. Bitte melden Sie sich erneut an.';
                }
                
                alert(errorMessage);
                // Show login screen again on error
                document.getElementById('initialLoading').style.display = 'none';
                document.getElementById('loginScreen').style.display = 'block';
            }
        }

        async function logout() {
            if (confirm('Sind Sie sicher, dass Sie sich abmelden m√∂chten?')) {
                if (passwordManager) {
                    await passwordManager.logout();
                }
                passwordManager = null;
                document.getElementById('loginScreen').style.display = 'block';
                document.getElementById('mainContent').style.display = 'none';
                document.getElementById('topActions').style.display = 'none';
                document.getElementById('passwordsContainer').innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Lade Passw√∂rter...</p>
                    </div>
                `;
            }
        }

        function showAddPasswordModal() {
            currentEditingId = null;
            document.getElementById('passwordForm').reset();
            
            // Reset to password type by default
            document.getElementById('entryType').value = 'password';
            toggleEntryTypeFields(); // This will set the correct modal title and show/hide fields
            
            document.getElementById('passwordModal').style.display = 'block';
            if (passwordManager) passwordManager.hydrateFolderSelects();
        }

        function editPassword(id) {
            const entry = passwordManager.passwords.find(p => p.id === id);
            if (entry) {
                currentEditingId = id;
                const entryType = entry.type || 'password';
                
                // Set entry type
                document.getElementById('entryType').value = entryType;
                toggleEntryTypeFields(); // This will set the correct modal title and show/hide fields
                
                // Set common fields
                document.getElementById('title').value = entry.title;
                if (passwordManager) passwordManager.hydrateFolderSelects();
                const folderSelect = document.getElementById('passwordFolder');
                if (folderSelect) folderSelect.value = entry.folderId || '';
                document.getElementById('notes').value = entry.notes || '';
                
                // Set type-specific fields
                switch(entryType) {
                    case 'password':
                        document.getElementById('username').value = entry.username || '';
                        document.getElementById('password').value = entry.password || '';
                        document.getElementById('urlCommon').value = entry.url || '';
                        if (entry.password) {
                            passwordManager.updatePasswordStrength(entry.password);
                        }
                        break;
                    case 'website':
                    case 'link':
                        document.getElementById('url').value = entry.url || '';
                        break;
                    case 'note':
                        document.getElementById('content').value = entry.content || '';
                        document.getElementById('urlCommon').value = entry.url || '';
                        break;
                }
                
                document.getElementById('passwordModal').style.display = 'block';
            }
        }

        async function deletePassword(id) {
            await passwordManager.deletePassword(id);
        }



        function generatePassword() {
            if (passwordManager) {
                const generatedPassword = passwordManager.generateSecurePassword();
                document.getElementById('password').value = generatedPassword;
                passwordManager.updatePasswordStrength(generatedPassword);
            }
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                passwordManager.showNotification('In Zwischenablage kopiert!', 'success');
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                passwordManager.showNotification('In Zwischenablage kopiert!', 'success');
            });
        }

        function togglePasswordVisibility(id) {
            const input = document.getElementById(`pwd-${id}`);
            if (input.type === 'password') {
                input.type = 'text';
            } else {
                input.type = 'password';
            }
        }

        function toggleModalPasswordVisibility() {
            const input = document.getElementById('password');
            if (!input) return;
            input.type = input.type === 'password' ? 'text' : 'password';
        }

        // Toggle fields based on entry type
        function toggleEntryTypeFields() {
            const entryType = document.getElementById('entryType').value;
            const passwordFields = document.getElementById('passwordFields');
            const linkFields = document.getElementById('linkFields');
            const noteFields = document.getElementById('noteFields');
            const urlFieldCommon = document.getElementById('urlFieldCommon');
            const generatePasswordBtn = document.getElementById('generatePasswordBtn');
            const modalTitle = document.getElementById('modalTitle');
            
            // Hide all specific fields first
            passwordFields.style.display = 'none';
            linkFields.style.display = 'none';
            noteFields.style.display = 'none';
            
            // Update modal title and show relevant fields
            switch(entryType) {
                case 'password':
                    modalTitle.textContent = 'Passwort hinzuf√ºgen';
                    passwordFields.style.display = 'block';
                    urlFieldCommon.style.display = 'block';
                    generatePasswordBtn.style.display = 'block';
                    // Make password fields required
                    document.getElementById('username').required = true;
                    document.getElementById('password').required = true;
                    break;
                case 'website':
                    modalTitle.textContent = 'Webseite hinzuf√ºgen';
                    linkFields.style.display = 'block';
                    urlFieldCommon.style.display = 'none';
                    generatePasswordBtn.style.display = 'none';
                    // Make URL required for websites
                    document.getElementById('url').required = true;
                    break;
                case 'link':
                    modalTitle.textContent = 'Link/Bookmark hinzuf√ºgen';
                    linkFields.style.display = 'block';
                    urlFieldCommon.style.display = 'none';
                    generatePasswordBtn.style.display = 'none';
                    document.getElementById('url').required = true;
                    break;
                case 'note':
                    modalTitle.textContent = 'Notiz hinzuf√ºgen';
                    noteFields.style.display = 'block';
                    urlFieldCommon.style.display = 'block';
                    generatePasswordBtn.style.display = 'none';
                    // Make content required for notes
                    document.getElementById('content').required = true;
                    break;
            }
            
            // Reset requirements for fields that are hidden
            if (entryType !== 'password') {
                document.getElementById('username').required = false;
                document.getElementById('password').required = false;
            }
            if (entryType !== 'website' && entryType !== 'link') {
                document.getElementById('url').required = false;
            }
            if (entryType !== 'note') {
                document.getElementById('content').required = false;
            }
        }

        // Open URL helper for compact rows
        function openEntryUrl(url) {
            try {
                const normalized = passwordManager ? passwordManager.normalizeUrl(url) : url;
                window.open(normalized, '_blank', 'noopener,noreferrer');
            } catch (_) {
                window.open(url, '_blank', 'noopener,noreferrer');
            }
        }

        async function exportData() {
            if (passwordManager) {
                await passwordManager.exportData();
            }
        }

        async function importData(event) {
            const file = event.target.files[0];
            if (file && passwordManager) {
                try {
                    // Pr√ºfe den Dateityp
                    if (file.name.endsWith('.json')) {
                        const text = await file.text();
                        const data = JSON.parse(text);
                        
                        // Pr√ºfe ob es verschl√ºsselte oder unverschl√ºsselte Daten sind
                        if (data.encrypted && data.iv && data.salt) {
                            // Verschl√ºsselte Daten - verwende normale Import-Methode
                            await passwordManager.importData(file);
                        } else if (data.passwords && Array.isArray(data.passwords)) {
                            // Unverschl√ºsselte Daten - direkter Import
                            await passwordManager.importUnencryptedData(data);
                        } else {
                            throw new Error('Ung√ºltiges JSON-Format. Erwarte entweder verschl√ºsselte Daten oder ein passwords-Array.');
                        }
                    } else {
                        // Andere Dateitypen (CSV, etc.)
                        await passwordManager.importData(file);
                    }
                } catch (error) {
                    passwordManager.showNotification('Import-Fehler: ' + error.message, 'error');
                }
            }
            event.target.value = ''; // Reset file input
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modals = document.getElementsByClassName('modal');
            for (let modal of modals) {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            }
        }

        // Master Password Management Functions
        async function showMasterPasswordManager() {
            document.getElementById('masterPasswordModal').style.display = 'block';
            await loadMasterPasswordsList();
    try {
        const tempManager = new PasswordManager();
        const isSet = await tempManager.checkMasterPasswordStatus();
        const group = document.getElementById('existingMasterPasswordGroup');
        if (group) group.style.display = isSet ? 'block' : 'none';
        const input = document.getElementById('existingMasterPasswordConfirm');
        if (input) input.required = !!isSet;
    } catch (_) {}
        }

        async function loadMasterPasswordsList() {
            try {
                const tempManager = new PasswordManager();
                const masterPasswords = await tempManager.getMasterPasswords();
                
                const container = document.getElementById('masterPasswordsList');
                
                if (masterPasswords.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #7f8c8d;">Keine Master-Passw√∂rter vorhanden.</p>';
                    return;
                }

                container.innerHTML = masterPasswords.map(mp => `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 15px; border: 1px solid #e1e8ed; border-radius: 8px; margin-bottom: 10px;">
                        <div>
                            <strong>${mp.name}</strong>
                            <br>
                            ${mp.hint ? `<div style="color:#6b7280; font-size:12px; margin:4px 0;">Hinweis: ${mp.hint.replace(/</g,'&lt;').replace(/>/g,'&gt;')}</div>` : ''}
                            <small style="color: #7f8c8d;">Erstellt: ${new Date(mp.createdAt).toLocaleDateString('de-DE')}</small>
                        </div>
                        <button class="btn btn-danger" onclick="removeMasterPassword('${mp.id}')" style="padding: 8px 15px; font-size: 14px;">
                            L√∂schen
                        </button>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Error loading master passwords:', error);
                document.getElementById('masterPasswordsList').innerHTML = '<p style="color: #e74c3c;">Fehler beim Laden der Master-Passw√∂rter.</p>';
            }
        }

        async function openConfirmDialog({ title, message, requirePassword = false, requirePasswordConfirm = false, passwordLabel = 'Passwort', passwordConfirmLabel = 'Passwort wiederholen' }) {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmModal');
                const titleEl = document.getElementById('confirmTitle');
                const msgEl = document.getElementById('confirmMessage');
                const group = document.getElementById('confirmPasswordGroup');
                const group2 = document.getElementById('confirmPassword2Group');
                const input = document.getElementById('confirmPasswordInput');
                const input2 = document.getElementById('confirmPassword2Input');
                const label1 = document.getElementById('confirmPasswordLabel');
                const label2 = document.getElementById('confirmPassword2Label');
                const cancelBtn = document.getElementById('confirmCancelBtn');
                const okBtn = document.getElementById('confirmOkBtn');

                titleEl.textContent = title || 'Best√§tigen';
                msgEl.textContent = message || '';
                group.style.display = requirePassword ? 'block' : 'none';
                group2.style.display = requirePasswordConfirm ? 'block' : 'none';
                if (label1) label1.textContent = passwordLabel;
                if (label2) label2.textContent = passwordConfirmLabel;
                input.value = '';
                if (input2) input2.value = '';
                modal.style.display = 'block';

                const cleanup = () => {
                    cancelBtn.onclick = null;
                    okBtn.onclick = null;
                    modal.style.display = 'none';
                };

                cancelBtn.onclick = () => { cleanup(); resolve(null); };
                okBtn.onclick = () => {
                    const val = requirePassword ? input.value : true;
                    if (requirePassword && !val) return;
                    if (requirePasswordConfirm) {
                        const confirmVal = input2.value;
                        if (!confirmVal) return;
                        if (val !== confirmVal) {
                            showToast('Passw√∂rter stimmen nicht √ºberein.', 'error');
                            return;
                        }
                        cleanup();
                        resolve(val);
                        return;
                    }
                    cleanup();
                    resolve(val);
                };
            });
        }

        async function promptPassword(title, message) {
            return await openConfirmDialog({ title, message, requirePassword: true });
        }

        async function promptNewPasswordWithConfirm(minLength = 8) {
            while (true) {
                const pw = await openConfirmDialog({
                    title: 'Passwort festlegen',
                    message: `Bitte ein Passwort mit mindestens ${minLength} Zeichen eingeben:`,
                    requirePassword: true,
                    requirePasswordConfirm: true,
                    passwordLabel: 'Passwort',
                    passwordConfirmLabel: 'Passwort wiederholen'
                });
                if (!pw) return null;
                if (pw.length < minLength) {
                    showToast(`Bitte mindestens ${minLength} Zeichen.`, 'error');
                    continue;
                }
                return pw;
            }
        }

        async function removeMasterPassword(id) {
            const proceed = await openConfirmDialog({
                title: 'Master-Passwort l√∂schen',
                message: 'Sind Sie sicher, dass Sie dieses Master-Passwort l√∂schen m√∂chten? Dies kann nicht r√ºckg√§ngig gemacht werden.'
            });
            if (!proceed) return;
            const confirmingPassword = await openConfirmDialog({
                title: 'Best√§tigen',
                message: 'Zur Best√§tigung bitte das zu l√∂schende Master-Passwort eingeben.',
                requirePassword: true
            });
            if (!confirmingPassword) return;

            try {
                const tempManager = new PasswordManager();
                await tempManager.removeMasterPassword(id, confirmingPassword);
                await loadMasterPasswordsList();
                showToast('Master-Passwort gel√∂scht', 'success');
                try {
                    const list = await tempManager.getMasterPasswords();
                    if (!Array.isArray(list) || list.length === 0) {
                        closeModal('masterPasswordModal');
                    }
                } catch (_) {}
            } catch (error) {
                let msg = String(error && error.message ? error.message : 'Unbekannter Fehler');
                if (/invalid\s+master\s+password/i.test(msg)) {
                    msg = 'Falsches Master-Passwort. Bitte erneut eingeben.';
                }
                showToast('Fehler beim L√∂schen: ' + msg, 'error');
            }
        }

        // Initialize the app
        // Helper function to get cached password directly from storage
        const getCachedPasswordDirect = () => {
            try {
                // Try sessionStorage first
                let cached = sessionStorage.getItem('pwa_cached_mp');
                let timestamp = sessionStorage.getItem('pwa_session_timestamp');
                
                // If not found in sessionStorage, try localStorage backup
                if (!cached || !timestamp) {
                    cached = localStorage.getItem('pwa_cached_mp_backup');
                    timestamp = localStorage.getItem('pwa_session_timestamp_backup');
                }
                
                if (!cached || !timestamp) return null;
                
                // Check if cache is not older than 1 minute (for testing)
                const age = Date.now() - parseInt(timestamp);
                const maxAge = 1 * 60 * 1000; // 1 minute
                
                if (age > maxAge) {
                    return null;
                }
                
                return atob(cached);
            } catch (error) {
                console.warn('Could not retrieve cached password directly:', error);
                return null;
            }
        };

        document.addEventListener('DOMContentLoaded', async () => {
            try {
                // Test sessionStorage functionality first
                try {
                    sessionStorage.setItem('test_key', 'test_value');
                    const testValue = sessionStorage.getItem('test_key');
                    sessionStorage.removeItem('test_key');
                    console.log('üß™ SessionStorage test:', testValue === 'test_value' ? 'PASSED' : 'FAILED');
                } catch (error) {
                    console.error('‚ùå SessionStorage not available:', error);
                }
                
                // Check for cached password BEFORE creating PasswordManager
                const cachedPassword = getCachedPasswordDirect();
                console.log('üîë Pre-check cached password:', !!cachedPassword);
                
                // Debug info removed - no longer needed
                
                if (cachedPassword) {
                    console.log('üîÑ Found cached password, attempting automatic re-login...');
                    try {
                        // Show loading state
                        document.getElementById('loginScreen').style.display = 'none';
                        document.getElementById('initialLoading').style.display = 'flex';
                        document.querySelector('#initialLoading .loading-content p').textContent = 'Automatische Anmeldung...';
                        
                        // Create password manager and try auto-login
                        const tempManager = new PasswordManager();
                        await tempManager.verifyMasterPassword(cachedPassword);
                        
                        // Success! Set as main password manager and show main content
                        passwordManager = tempManager;
                        passwordManager.isAuthenticated = true;
                        passwordManager.cachedMasterPassword = cachedPassword;
                        
                        // Initialize activity tracking (only in server mode)
                        passwordManager.initActivityTracking();
                        
                        // Load data and show main content
                        await Promise.all([passwordManager.loadFolders(), passwordManager.loadPasswords()]);
                        document.getElementById('initialLoading').style.display = 'none';
                        document.getElementById('mainContent').style.display = 'block';
                        document.getElementById('topActions').style.display = 'flex';
                        
                        // Start session timer after successful auto-login
                        passwordManager.startSessionTimer();
                        
                        console.log('‚úÖ Automatic re-login successful');
                        return;
                    } catch (error) {
                        console.warn('‚ùå Automatic re-login failed:', error.message);
                        
                        // Clear invalid cached password
                        try {
                            sessionStorage.removeItem('pwa_cached_mp');
                            sessionStorage.removeItem('pwa_session_timestamp');
                            localStorage.removeItem('pwa_cached_mp_backup');
                            localStorage.removeItem('pwa_session_timestamp_backup');
                        } catch (e) {
                            console.warn('Could not clear cached password:', e);
                        }
                        
                        // Fall back to normal login
                        document.getElementById('initialLoading').style.display = 'none';
                        document.getElementById('loginScreen').style.display = 'block';
                    }
                }
                
                // No cached password or auto-login failed - continue with normal session check
                const tempManager = new PasswordManager();
                
                console.log('üîç Checking session status on app load...');
                let isAuthenticated = await tempManager.checkSessionStatus();
                console.log('üìã Session status check result:', isAuthenticated);
                
                if (isAuthenticated) {
                    // User is already logged in, show main content
                    passwordManager = tempManager;
                    passwordManager.isAuthenticated = true;
                    
                    // Initialize activity tracking for session extension
                    passwordManager.initActivityTracking();
                    
                    // Start session timer
                    passwordManager.startSessionTimer();
                    
                    await Promise.all([passwordManager.loadFolders(), passwordManager.loadPasswords()]);
                    document.getElementById('initialLoading').style.display = 'none';
                    document.getElementById('mainContent').style.display = 'block';
                    document.getElementById('topActions').style.display = 'flex';
                    return;
                }
                
                // Check if session can be recovered (user has data but no active session)
                if (tempManager.sessionRecoverable) {
                    // Show recovery notice in login screen
                    document.getElementById('sessionRecoveryNotice').style.display = 'block';
                }
                
                const isSet = await tempManager.checkMasterPasswordStatus();
                
                if (isSet) {
                    // Master password exists - show login screen
                    document.getElementById('loginTitle').textContent = 'Master-Passwort eingeben';
                    document.getElementById('loginDescription').textContent = 'Geben Sie Ihr Master-Passwort ein, um auf Ihre verschl√ºsselten Passw√∂rter zuzugreifen.';
                    document.getElementById('loginButton').textContent = 'Anmelden';
                } else {
                    // First time setup - show registration screen
                    document.getElementById('loginTitle').textContent = 'Master-Passwort erstellen';
                    document.getElementById('loginDescription').textContent = 'Erstellen Sie ein sicheres Master-Passwort f√ºr Ihren Passwort-Manager.';
                    document.getElementById('loginButton').textContent = 'Erstellen & Anmelden';
                }

                // Show appropriate screen
                document.getElementById('initialLoading').style.display = 'none';
                document.getElementById('loginScreen').style.display = 'block';
                
                // Setup master password form
                document.getElementById('masterPasswordForm').addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const name = document.getElementById('masterPasswordName').value.trim() || 'Master Password';
                    const password = document.getElementById('newMasterPassword').value;
                    const confirmPassword = document.getElementById('confirmNewMasterPassword').value;
                    const confirmingPassword = document.getElementById('existingMasterPasswordConfirm').value;

                    if (password.length < 8) {
                        alert('Das Master-Passwort muss mindestens 8 Zeichen lang sein.');
                        return;
                    }

                    if (password !== confirmPassword) {
                        alert('Die Passw√∂rter stimmen nicht √ºberein.');
                        return;
                    }

                    try {
                        const tempManager = new PasswordManager();
                        const isSet = await tempManager.checkMasterPasswordStatus();
                        if (isSet && !confirmingPassword) {
                            alert('Bitte best√§tigen Sie mit Ihrem bestehenden Master-Passwort.');
                            return;
                        }
                        tempManager.confirmingPasswordForNew = isSet ? confirmingPassword : undefined;
                        const hint = document.getElementById('newMasterPasswordHint').value.trim();
                        await tempManager.addMasterPassword(password, name, hint);
                        
                        // Clear form
                        document.getElementById('masterPasswordForm').reset();
                        
                        // Reload list
                        await loadMasterPasswordsList();
                        
                        alert('Master-Passwort erfolgreich hinzugef√ºgt!');
                    } catch (error) {
                        alert('Fehler beim Hinzuf√ºgen: ' + error.message);
                    }
                });
            } catch (error) {
                console.error('Error checking master password status:', error);
                // Show login screen on error
                document.getElementById('initialLoading').style.display = 'none';
                document.getElementById('loginScreen').style.display = 'block';
            }
        });
    </script>
</body>
</html> 